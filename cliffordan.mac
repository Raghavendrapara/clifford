/*******************************
Clifford algebra
a lightweight package for performing Geometric Algebra calculations

Clifford analysis

version 1.1 Date 16 Dec 2015

@depends 'clifford

**********************************
 * @license This library is free software	 you can redistribute it and/or
 *      modify it under the terms of the GNU Lesser General Public
 *      License as published by the Free Software Foundation	 either
 *      version 2.1 of the License, or (at your option) any later version.
 *
 *      This library is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY	 without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *       Lesser General Public License for more details.
 *
 *      You should have received a copy of the GNU Lesser General Public
 *      License along with this library	 if not, write to the Free Software
 *      Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
 stringdisp :true;
 
if get('clifford,'version)=false then (

	err:errcatch(
		load("clifford.mac")
	),
	if emptyp(err) then (

	"inner product",
	infix ("|", 130, 129),	
	"|"(a, b):= if scalarp(a) and scalarp(b) then a*b else expand((a.b + b.a)/2),
	texput ("|", " \\circ ", infix),
 
	"outer product",
	infix("&", 130, 129),
	"&"(a, b):=if scalarp(a) and scalarp(b) then 0 else expand((a.b - b.a)/2),
	texput ("&", " \\wedge ", infix)
	)
);

/* 
extaracts equivalence information from the facts database
*/ 
iseq(x):= block([ vv, nil, inflag:true], 
	mode_declare(vv, list), 
	vv:sublist(facts(x), lambda([u], not freeof('equal , u ))),
	if not emptyp(vv) then (
		vv:map(lambda([u],   inpart(u,1,1)=inpart(u,2)- (inpart(u,1) -inpart(u,1,1)) ), vv),
		vv[1]
	) else nil 
);

/* 
declares equivalence  
*/ 
eqassume(st):=block([simp:false, ll:lhs(st), rr:rhs(st) ] ,
	if equal(ll,rr)#true then
	assume(equal(ll,rr)) else 'done
);

/* 
substitutes equivalences
*/
declare (eqsubst, evfun);

eqsubst( eq):=block( [aa, ss, sop, lst],
	mode_declare(lst, list), 
	sop: inop(eq),
	if sop = 'nil then (
		aa:iseq(eq),
		if aa#'nil then ss:ratsubst(rhs(aa), lhs(aa), eq)
	) else (
		ss: factor(eq),
		lst: inargs(ss),
		for x in lst do (
			aa:iseq(x),
			if aa#'nil then ss:ratsubst(rhs(aa), lhs(aa), ss)
		)
	),
	ss
);

/* 
simplifies based on equivalences
*/
doteqsimp(expr):=block([ gr:grade(expr)],
	gr:map(factor, gr),
	gr:map(eqsubst, gr),
	substinpart("+", gr, 0)
);


dependsv(F, var):= block([ ee], 
	if subvarp(var) then var:op(var),
	if subvarp(F) then F:op(F),
	ee:buildq([var], declare(var, scalar) ), 
	ev(ee, nouns),
	ee:buildq([F], declare(F, scalar) ), 
	ev(ee, nouns),
	ee:buildq([var],  if listp(var) then makelist(var[k], k, length(var)) 
	else var ), 
	ev(depends(F,ee), nouns)
);


 
/*
 Analysis functions

*/

/* total differentiation; 
no assumptions */
totdiff(f,x, [lv]):=block( [ret:0],
	if mapatom(x) then 
		ret: diff( f, x )
	else (
		if emptyp(lv) then
			lv:listofvars(x)
		else 
			lv:lv[1],
		display(lv),
		for u in lv do
			if symbolp(u) then
				ret: ret + diff(f, u) / diff(x, u)
	),
	ret
);


/* 
Clifford-valued
total differentiation; */
ctotdiff(f,x):=block( [ret:0, lv],
	if mapatom(x) then 
		ret: diff( f, x )
	else (
		lv: sublist( listofvars(x), lambda ([z], freeof(asymbol,z))),
		"display(lv)",
		for u in lv do 
			ret: ret + cinv(diff(x, u)). subst(".", "*", diff( f, u ))
	),
	ret
);



/*
 vector derivative
*/
vectdiff(f, x, [k] ):=block ([s, n:1, m, i ],
	if listp(x) then n:length(x) else x:[x],
	if n>ndim then error("size mismatch"),
	if emptyp(k) then k:1 else k: k[1],
	for p:1 thru k do (
		i:1, s:0,
		for m in x do (
			if not emptyp(m) then
				s: s+ dotinvsimp(1/asymbol[i]). subst(".", "*", pardiff( f, m )),
			i:i+1
		),
		s:cliffsimpall(s),
		f:s
	),
	s
);

/*
 multi vector derivative
*/
%divsimp:false;

mvectdiff(f, x, [k] ):=block ([s:0, n:1, m, es],
	if emptyp(k) then k:1 else k: k[1],
	x:expand(x),
	for p:1 thru k do (
		s:ctotdiff(f, x),
		s:cliffsimpall(s),
		f:s
	),
	if %divsimp=true then (
		es: sublist( listofvars(x), lambda ([z], not freeof(asymbol, z))),
		"display(es)",
		if not emptyp(es) then
			s:simpfact(s, es)
	),
	s
);

pardiff(f, x, [k] ):=block( [ret:0 ],
	if emptyp(k) then k:1 else k: k[1],
	if mapatom(x) then 
		ret:diff(f, x, k )
	else (
		ret:diff(ratsubst( u, x, f),u, k),
		ret:subst(u=x,ret)
	),
	ret
);

/*
 multi vector partial derivative
*/
parmvectdiff(f, x, [k] ):=block ([s, n:1, m, i, ee, xx, df, qq, es ],
	[ee, xx]:clicoeff(x, 'list),
	display(xx),
	if emptyp(k) then k:1 else k: k[1],
	es: sublist( listofvars(x), lambda ([z], not freeof(asymbol, z))),
	"display(es)",
	for p:1 thru k do (
		i:1, s:0,
		for m in xx do (			
			df: expand(pardiff( f, m )),
			qq: dotinvsimp(1/ ee[i]),
			s: s +  cliffsimpall(qq . subst(".", "*", df )),
			i:i+1
		),
		if %divsimp=true then (
			s:cliffsimpall(s),
			if not emptyp(es) then
				s:simpfact(s, es)
		),
		f:s
	),
	s
);

/*
convderiv(f, t, x, d):=block( [ nabla, ss:0 ],
	if not symbolp(t) then error(t, " must be a symbol"),	
	if d#0 then (
		nabla: mvectdiff(f, x, 2),
		ss:%iv.( d | nabla)
	),
	diff(f, t) - 1/2* ss
);
*/


/*
 directional, inner, derivative

invectdiff(f, x, [k] ):=block ([s, n:1, m, i, ee, xx, df, qq, es ],
	[ee, xx]:clicoeff(x,'list),
	if emptyp(k) then k:1 else k: k[1],
		es: sublist( listofvars(x), lambda ([z], not freeof(asymbol, z))),
	display(es),
	for p:1 thru k do (
		i:1, s:0,
		for m in xx do (
			if mapatom(m) then (
				df: expand(diff( f, m )),
				qq: dotinvsimp(1/ ee[i]),
				s: s +  cliffsimpall(qq | subst(".", "*", df ))
				),
			i:i+1
		),
		s:cliffsimpall(s),
		f:s
	),
	if not emptyp(es) then
				s:simpfact(s, es),
	s
);
*/

svectdiff(f, x, [k] ):=block ([ df],
	if emptyp(k) then k:1 else k: k[1],
	for p:1 thru k do (
		df:mvectdiff(f, x, p),
		df:scalarpart(df)
		),
	df
);
/*
 exterior, dual, vector derivative

extvectdiff(f, x, [k] ):=block ([s, n:1, m, i, ee, xx, df, qq ],
	[ee, xx]:clicoeff(x, 'list),
	if emptyp(k) then k:1 else k: k[1],
	for p:1 thru k do (
		i:1, s:0,
		for m in xx do (
			if mapatom(m) then (
				df: expand(diff( f, m )),
				qq: dotinvsimp(1/ ee[i]),
				s: s +  cliffsimpall(qq & subst(".", "*", df))
				),
			i:i+1
		),
		s:cliffsimpall(s),
		f:s
	),
	s
);
*/
vvectdiff(f, x, [k] ):=block ([ df],
	if emptyp(k) then k:1 else k: k[1],
	for p:1 thru k do (
		df:mvectdiff(f, x, p),
		df:nscalarpart(df)
		),
	if %divsimp=true then 
			df:simpfact(df, %elements),
	df
);

/*
 Euler-Lagrange equations

EuLagEq1(_F, tt, pvars):=block ([eq:0, p, pv, len, ret:[]],
	[p, pv]:pvars,
	display(p, pv),
	if listp(p) then
		for i:1 thru length (p) do
			if not emptyp(p[i]) then
				push(pv[i]='diff(p[i], tt), ret)
	else 
		push(pv='diff(p, tt), ret),
	eq:vectdiff(_F, p)-'diff(vectdiff(_F, pv), tt),
	[ ret, eq=0]
);
*/

/*
EL  field Lagrangians

EuLagEq2(_F, tt, pvars):=block ([eq:0, p, pv, ee, xx, len, qq, yy:[], ss:[], zz:[]],
	[p, pv]:pvars,
	display(p, pv),	 
	[ee, xx]:clicoeff(p, 'list),
	[ee, vv]:clicoeff(pv, 'list),
	for j:1 thru length(xx) do (
		push(vv[j]='diff(xx[j], tt), yy),
		push(vv[j]=vv[j](tt), ss),
		push(vv[j](tt)=vv[j], zz)
	),
	qq:parmvectdiff(_F, pv),
	display(qq),
	qq:psubst(ss, qq),
	eq:parmvectdiff(_F, p)-psubst(zz, mvectdiff(qq , tt)),
	expand(psubst(yy, eq))
);
*/

EuLagEq2(_F, tt, pvars):=block ([eq:0, p, pv, ee, xx, len, qq, yy:[], ss:[], zz:[], es:[], ez:[], vv  ],
	[p, pv]:pvars,
	display(p, pv),	 
	[ee, vv]:clicoeff(pv, 'list),
	lv: sublist( listofvars(tt), lambda ([z],  freeof(asymbol, z) )),	
	if not mapatom(vv) then
		vv: substinpart("[",vv, 0)
	else vv:[vv],
	for j:1 thru length(vv) do (
		for i:1 thru length(lv) do ( 
			if inop(vv[j])#"+" then (
				push(vv[j]=vv[j](lv[i]), ss),
				push(vv[j](lv[i])=vv[j], zz)
			)
		)
	),
	/*display(ss, zz),*/
	qq:parmvectdiff(_F, pv),
	display(qq),
	qq:psubst(ss, qq),
	eq:parmvectdiff(_F, p)-psubst(zz, mvectdiff(qq , tt)),
	es: sublist( listofvars(eq), lambda ([z], not freeof(asymbol, z))),
	if not emptyp(es) then
		eq:simpfact(eq, es),
	eq
);

/*
 EL particle lagrangians
*/
EuLagEq3(_F, tt, pvars):=block([ee, xx, ss:0, es],
	[ee, xx]:clicoeff(_F, 'list),
	for i:1 thru length(ee) do (
		display(xx[i], ee[i]),
		ss:ss + ee[i] . ciEL1(xx[i], tt, pvars, 'list)
		),
	es: sublist( listofvars(ss), lambda ([z], not freeof(asymbol, z))),
	if not emptyp(es) then
		ss:simpfact(ss, es),
	ss
);

/*
convective derivative
*/
convderiv(f, t, xx):=block( [ lv, n:1, u, nabla:[], lv, ss:0, m, es:[], s:0, ez:[], aa:[] , bb:[] ],
	if not symbolp(t) then error(t, " must be a symbol"),	
	lv:listofvars(xx),
 	xx:expand(xx),
	es: sublist( lv, lambda ([z], not freeof(asymbol, z))),
	ez: sublist( lv, lambda ([z],   freeof(asymbol, z))),
	for j:1 thru length(ez) do (
			push(ez[j]=ez[j](t), aa),
			push(ez[j](t)=ez[j], bb)
		),
	if mapatom(xx) then 
		nabla:[diff( psubst(aa, xx),t)]
	else
		nabla:diff(args(psubst(aa, xx)),t),
	/*display(nabla),*/
	ss:diff(f, t), 
	n:1, s:0,
	if mapatom(xx) then 
		 xx:[xx],
    for m in xx do (
		s:s+ nabla[n]. ctotdiff(f, m),			
		n:n+1
	),
	ss:ss+s,
	if %divsimp=true then (
			ss:cliffsimpall(ss),
			if not emptyp(es) then
				ss:simpfact(ss, es)
	),
	ss:psubst(bb, ss)
);


ciEL1(_F, tt, pvars, smat):=block([eq, p, pv, qq, ee, aa:[], bb:[], es:[], ez:[] ],
	if not listp(pvars) then error("list required"),
	[p, pv]:pvars,
	eq:parmvectdiff(_F, p),
 	es: sublist( listofvars(p), lambda ([z],  freeof(asymbol, z))),	 
	ez: sublist( listofvars(pv), lambda ([z],  freeof(asymbol, z))),	
	/*display(es, ez), */
	 display(pv, eq),
	 for j:1 thru length(ez) do (
		push(ez[j]='diff(es[j], tt, 1), aa),
		push('diff(es[j], tt, 1)=ez[j] , bb)
	),
	aa:reverse(aa),
	bb:reverse(bb),
	/*display (aa, bb),*/
	depends(es, tt),
	
	qq: parmvectdiff(_F, pv),
	eq:eq - convderiv(qq, tt, pv),
	display(qq),
	eq: psubst(bb, eq),
	
	ee:buildq([es], remove(es, dependency)), 
	ev(ee, nouns),

	if smat='list then 
		eq:subst(aa, eq)
	else if smat='mat then  
		eq:bdecompose(eq),
	eq
);
 
/*
ciEL(_F, tt, pvars, smat):=block([eq, p, qq, rr, ret:[], es, z ],
	if not listp(pvars) then error("list required"),
	 len:length(pvars),
	 p:pvars[1],
	 eq:mvectdiff(_F, p),
	 z: sublist( listofvars(p), lambda ([z],  freeof(asymbol, z))),
	 push(t,z),
	 display(p, eq),
	 if len>1 then (
		for i:2 thru len do (
			p:pvars[i],
			es: sublist( listofvars(p), lambda ([z],  freeof(asymbol, z))),	 
			"display(es, p)",
			map(lambda([u], if subvarp(u) then u:op(u), depends(u, tt)), es),	 
			
			qq: parmvectdiff(_F, p),
			display(qq),
			eq:eq + (-1)^(i-1)*diff( qq, tt, i-1 ) 
			push(p='diff(pvars[1], tt, i-1), ret),
			
			map(lambda([u], if subvarp(u) then u:op(u), remove(u, dependency)), es)
		),
		ret:reverse(ret)
	),
	if smat='list then 
		subst(ret, eq)
	else if smat='mat then  
		bdecompose(eq)
);
 */
EL(_F, q, pvars):=block ([eq:0, p, pv, qq, rr, len, ret:[]],
	if not listp(pvars) then error("list required"),
	 len:length(pvars),
	 p:pvars[1],
	 eq:pardiff(_F, p),
	 if len>1 then (
		for i:2 thru len do (
			pv:pvars[i],
			qq: subst('pv(q), pv, pardiff(_F, pv)),
			/*qq: pardiff(_F, pv),*/
			display(qq),
			for j:1 thru i-1 do (
				rr:- convderiv(qq, q, p),				
				rr: subst('diff(p, q)='pv(q), rr),
				display(q, p, pv,  rr),
				eq:eq + subst( pv, 'pv(q), rr  ),
				/*eq:eq+ rr,*/
				qq:rr
			),
			push(pv='diff(pvars[1], q, i-1), ret)
		),
		ret:reverse(ret)
	),
	[ ret, eq]
);

/*
coordinate substitution
*/
coordsubst(rr, eqs):=block( [lv, ret:rr],
	lv: sublist( listofvars(rr), lambda ([z], freeof(asymbol,z))),
	if not listp(eqs) then eqs:[eqs],
	if length(eqs)#length(lv) then error("length mismatch"),
	for i:1 thru length(lv) do  
		ret:ratsubst(eqs[i], lv[i], ret),
	ret
);

put('cliffordan, 'v13,'version);
put('cliffordan, "Dimiter Prodanov", 'author);
put('cliffordan, "(C) - Dimiter Prodanov, 2015", 'copyright);

disp("package name: cliffordan.mac");
disp("author: ", get('cliffordan,'author));
disp("version:", get('cliffordan,'version));
disp("Recommended location: share/contrib");
disp("last update: 09 Jan 2016");