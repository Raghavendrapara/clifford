/*******************************
Clifford algebra
a lightweight package for performing Geometric Algebra calculations

Clifford analysis

@version 	1.8 Date 23 Aug 2017
		-  change of variables
		- bug fixes
		1.7 Date 12 Dec 2016
		- projection derivatives
		1.6.5 Date 13 Jun 2016
		1.6 Date 10 Apr 2016
		1.5 Date 20 Feb 2016
		1.2 Date 22 Jan 2016
		1.1 Date 16 Dec 2015

@depends 'clifford

**********************************
 * @license This library is free software	 you can redistribute it and/or
 *      modify it under the terms of the GNU Lesser General Public
 *      License as published by the Free Software Foundation	 either
 *      version 2.1 of the License, or (at your option) any later version.
 *
 *      This library is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY	 without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *       Lesser General Public License for more details.
 *
 *      You should have received a copy of the GNU Lesser General Public
 *      License along with this library	 if not, write to the Free Software
 *      Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
 stringdisp :true;
 declare(trigsimp, evfun);
 
if get('clifford,'version)=false then (
	
	err:errcatch(
		load("clifford.mac")
	),
	
	if emptyp(err) then (
	infix ("|", 130, 129),
	infix("&", 130, 129)
	/*
	"inner product",
	infix ("|", 130, 129),	
	"|"(a, b):=  expand((a.b + cinvolve(b).cinvolve(a))/2),
	texput ("|", " \\circ ", infix),
 
	"outer product",
	infix("&", 130, 129),
	"&"(a, b):= expand((a.b - cinvolve(b).cinvolve(a))/2),
	texput ("&", " \\wedge ", infix)
	*/
	)
	
);

if get('cliffordan,'version)=false then (
	remove("@", operator),
	"inner product",
	infix ("@", 130, 129),
	"@"(a, b):=  scprod(a,b),
	print("warning: redefining  @")
	/*
	simp:false,
	tellsimpafter(asymbol[kk] * asymbol[mm], if kk#mm then 0 else signature[kk]),
	tellsimpafter(asymbol[kk] * asymbol[mm] *bb, if kk#mm then 0 else signature[kk]*bb),
	tellsimpafter(aa[kk]^nn, if oddp(nn) then 0 else  signature[kk] ), 
	simp:true
	*/
);

%clverbose:false;
%divsimp:true;

/*
declaring dependencies
*/
dependsv(F, var):= block([ ee], 
	if subvarp(var) then var:op(var),
	if subvarp(F) then F:op(F),
	ee:buildq([var], declare(var, scalar) ), 
	ev(ee, nouns),
	ee:buildq([F], declare(F, scalar) ), 
	ev(ee, nouns),
	ee:buildq([var],  if listp(var) then makelist(var[k], k, length(var)) 
	else var ), 
	ev(depends(F,ee), nouns)
);

 
/*
 Analysis functions

*/

/* total differentiation; 
no assumptions */
totdiff(f, x, [lv]):=block( [ret:0],
	if mapatom(x) then 
		ret: diff( f, x )
	else (
		if emptyp(lv) then
			lv:listofvars(x)
		else 
			lv:lv[1],
		/*display(lv),*/
		for u in lv do
			if symbolp(u) then
				ret: ret + diff(f, u) / diff(x, u)
	),
	ret
);

diffp(expr):= inop(expr)=nounify('derivative);

/* total differentiation; 
 subsitutions*/
 /*diffsubst(deq, dvar, eq):=block([nn, zz, sop, sargs, u, ret, l, r, dsymb:nounify('derivative) ],
	if numberp(deq) then return(deq),

	sop:inop(deq),
	if op(eq)="=" then zz:rhs(eq) else error("provide explicit equation"),
	if inop(deq)="+" then 
		ret:map(lambda([u],  diffsubst(u, dvar, eq)), deq)
	else 
		if diffp(deq) then (
			sargs:inargs(deq),
			nn:sargs[3],

			if lhs(eq)=sargs[2] then (
				ret:subst(dsymb=lambda([ff, xx, nn],  'totdiff(ff, zz, [dvar])), deq),
				ret:ev(ret, nouns),
				if nn>1 then 
					for k:1 thru nn-1 do ret:totdiff(ret, zz, [dvar])			
			) else ret:deq
		) else (
			[l, r]: oppart(deq, lambda([u], freeof(dsymb, u))),
	
			if r#nil then
				r: diffsubst(r, dvar, eq)
			else r:1,
			l: subst(eq, l),
			ret:l*r
		),
	ret
);
*/
diffsubst(deq, dvar, eq):=block([nn, zz, u, sop, sargs, ret, l, r, dsymb:nounify('derivative) ],
	if numberp(deq) then return(deq),
	/*disp(deq),*/
	sop:inop(deq),
	if op(eq)="=" then zz:rhs(eq) else error("provide explicit equation"),
	if inop(deq)="+" then 
		ret:map(lambda([u], diffsubst(u, dvar, eq)), deq)
	else (
		ret:deq,
		if diffp(deq) then (
			sargs:inargs(deq),
			nn:sargs[3],
			/*display(lhs(eq), sargs[2]),*/
			if lhs(eq)=sargs[2] then (
				/*disp(deq),*/
				ret:ev(deq, diff),
				ret:subst(dsymb=lambda([ff, xx, nn], 
					if not mapatom(ff) then
						ff:subst(eq, ff), 
						'totdiff(ff, zz, [dvar])
					), ret),
				/*ret:subst(dsymb=lambda([ff, xx, nn], disp(ff, zz), totdiff(ff, zz, [dvar])), ret),	*/
				/*ret:subst(dsymb=lambda([ff, xx, nn],  totdiff(ff, zz, [dvar])), ret),	*/				
				ret:ev(ret, nouns),
				if nn>1 then 
					for k:1 thru nn-1 do ret:totdiff(ret, zz, [dvar]),
				/*display(ret),*/
				ret:subst(eq, ret)
			)		
		) else (
			[l, r]: oppart(deq, lambda([u], freeof(dsymb, u))),		
			/*display(l, r),*/		
			if r#nil then
				r: diffsubst(r, dvar, eq)
			else r:1,	
			l: subst(eq, l),
			ret:l*r
		)
	),
	ret
);


/* 
Clifford-valued
total differentiation; */
ctotdiff(f, x):=block( [ret:0, lv],
	if mapatom(x) then 
		ret: diff( f, x )
	else (
		lv: sublist( listofvars(x), lambda ([z], freeof(asymbol, z))),		
		for u in lv do 
			ret: ret + cinv(diff(x, u)). subst(".", "*", diff( f, u ))
	),
	ret
);


/* 
Christoffel symbols based on 
Clifford-valued
total differentiation; */
christoffel12_cli (x, ilst):=block([ek, eq, xi, xj, i, j, k, lv, dd, g1, g2],
	if not listp (ilst) and length (ilst)#3 then error ("not a list or bad length ", lst),
	[xk, xi, xj]:ilst,	
	dd:dotsimpc(expand(ctotdiff(x,  xi))),
	dd:dotsimpc(expand(ctotdiff(dd, xj))),
	dd:ratsimp(dd),
	dd:trigsimp(dd),
	/*display(dd),*/
	eq: diff(x, xk),
	ek: trigsimp(cinv(eq)),
	/*display(ek, eq, xi, xj),*/	
	g1: eq @ dd,
	g1:trigsimp(g1),
	g2: ek @ dd,
	g2:trigsimp(g2),
	[ g1, g2]
);

/* 
Christoffel symbols based on 
Clifford-valued
total differentiation; */
christoffel_table(x, lst, opt):=block([n],
	n:length(lst),
	if opt=1 then
		makelist(genmatrix( lambda([i,j], first(christoffel12_cli(x, [lst[k], lst[i] , lst[j]] ) )), n), k, n)
	else 
		makelist(genmatrix( lambda([i,j], second(christoffel12_cli(x, [lst[k], lst[i] , lst[j]] ) )), n), k, n)
);

/* 
Metrics table */
metrics(x, lst):=block([n, ek],
	ek: maplist (lambda([u], diff(x, u)), lst),
	/*disp(ek),*/
	n:length(lst),
	genmatrix( lambda([i,j], trigsimp( (ek[i] @ ek[j] ))), n)
);

/* 
 Clifford-valued
 directional derivative
 */
cdirdiff(f, v, x):=block( [ret:0, lv, uu:0, qq],
	if mapatom(x) then 
		ret: scalarpart(v)*diff( f, x )
	else (
		lv: sublist( listofvars(x), lambda ([z], freeof(asymbol, z))),		
		for u in lv do (
			qq: cinv(diff(x, u)),
			uu: scprod(qq , v),
			ret: ret + uu * subst(".", "*", diff( f, u ))
			)
	),
	ret:dotsimpc(ret),
	ret:clifact(ret)
);

cdirdualdiff(f, v, x):=block( [ret:0, lv, uu:0, qq, d],
	if mapatom(x) then 
		ret: scalarpart(v)*diff( f, x )
	else (
		d: clidual(v),
		lv: sublist( listofvars(x), lambda ([z], freeof(asymbol, z))),		
		for u in lv do (
			qq: cinv(diff(x, u)),
			uu: scprod(qq , d),
			ret: ret + uu * subst(".", "*", diff( f, u ))
			)
	),
	factorby(dotsimpc(ret), %elements)
);

cndirdiff(f, v, x):=block( [ret:0, lv, uu:0, qq],
	if mapatom(x) then 
		ret: scalarpart(v)*diff( f, x )
	else (
		lv: sublist( listofvars(x), lambda ([z], freeof(asymbol, z))),		
		for u in lv do (
			qq: cinv(diff(x, u)),
			uu: expand(qq . v) - scprod(qq , v),
			uu: dotsimpc(uu),
			ret: ret + uu. subst(".", "*", diff( f, u ))
			)
	),
	ret:expand(ret),
	factorby(dotsimpc(ret), %elements)
);

ctotprojdiff(f, v, x):=block( [ret:0, lv, uu:0, qq],
	if mapatom(x) then 
		ret: scalarpart(v)*diff( f, x )
	else (
		lv: sublist( listofvars(x), lambda ([z], freeof(asymbol, z))),		
		for u in lv do (
			qq: cinv(diff(x, u)),
			uu: expand(qq . v),
			uu: dotsimpc(uu),
			ret: ret + uu. subst(".", "*", diff( f, u ))
			)
	),
	ret:expand(ret),
	dotsimpc(ret)
);

ctotintdiff(f, x):=block( [ret:0, lv],
	if mapatom(x) then 
		ret: diff( f, x )
	else (
		lv: sublist( listofvars(x), lambda ([z], freeof(asymbol,z))),
		for u in lv do 
			ret: ret + cinv(diff(x, u)) | subst(".", "*", diff( f, u ))
	),
	ret
);

ctotextdiff(f, x):=block( [ret:0, lv],
	if mapatom(x) then 
		ret: diff( f, x )
	else (
		lv: sublist( listofvars(x), lambda ([z], freeof(asymbol,z))),
		for u in lv do 
			ret: ret + cinv(diff(x, u)) & subst(".", "*", diff( f, u ))
	),
	ret
);

/*
 multi vector derivative
*/
mvectdiff(f, x, [k] ):=block ([s:0, n:1, m, es],
	if emptyp(k) then k:1 else k: k[1],
	x:expand(x),
	for p:1 thru k do (
		s:ctotdiff(f, x),
		s:cliffsimpall(s),
		f:s
	),
	if %divsimp=true then (
		"display(es)",
		s:trigsimp(s),
		s:clifact(s)
	),
	s
);

 
/*
partial derivative
*/ 
pardiff(f, x, [k] ):=block( [ret:0, u:gensym() ],
	if emptyp(k) then k:1 else k: k[1],
	if mapatom(x) then 
		ret:diff(f, x, k )
	else (
		ret:diff(ratsubst( u, x, f), u, k),
		ret:subst(u=x,ret)
	),
	ret
);

/*
 vector derivative
 reference implementation
*/
vectdiff(f, x, [k] ):=block ([s, n:1, m, i ],
	if listp(x) then n:length(x) else x:[x],
	if n>ndim then error("size mismatch"),
	if emptyp(k) then k:1 else k: k[1],
	for p:1 thru k do (
		i:1, s:0,
		for m in x do (
			if not emptyp(m) then
				s: s+ cinv(asymbol[i]). subst(".", "*", pardiff( f, m )),
			i:i+1
		),
		s:cliffsimpall(s),
		f:s
	),
	s
);

/*
 multi vector partial derivative
*/
parmvectdiff(f, x, [k] ):=block ([s,  m, i, ee, xx, df, qq, es ],
	[ee, xx]:clicoeff2(x, 'list),
	if emptyp(k) then k:1 else k: k[1],
	es: sublist( listofvars(x), lambda ([z], not freeof(asymbol, z))),
	if %clverbose=true then 
		display(es),
	for p:1 thru k do (
		i:1, s:0,
		for m in xx do (			
			df: expand(pardiff( f, m )),
			qq: cinv(ee[i]),
			s: s +  cliffsimpall(qq . subst(".", "*", df )),
			i:i+1
		),
		if %divsimp=true then (
			if not emptyp(es) then
				s:simpfact(s, es)
		),
		f:s
	),
	clifact(s)
);


parmvectdirdiff(f, v, x, [k] ):=block ([s, ee, xx,  df, qq,  uu ],
	[ee, xx]:clicoeff2(x, 'list),
	if %clverbose=true then
		display(xx),
	if emptyp(k) then k:1 else k: k[1],
	for p:1 thru k do (
		s:0,
		for i:1 thru length(xx) do (			
			df: expand(pardiff( f, xx[i] )),
			qq: cinv(ee[i]),
			uu: scprod(qq , v),
			/*display(qq, uu, df),*/
			s: s +  cliffsimpall(uu*subst(".", "*", df ))
		),
		f:s
	),
	s
);

parmvectintdiff(f, x, [k] ):=block ([s, n:1, m, i, ee, xx, df, qq, es ],
	[ee, xx]:clicoeff2(x, 'list),
	if %clverbose=true then
		display(xx),
	if emptyp(k) then k:1 else k: k[1],
	es: sublist( listofvars(x), lambda ([z], not freeof(asymbol, z))),
	"display(es)",
	for p:1 thru k do (
		i:1, s:0,
		for m in xx do (			
			df: expand(pardiff( f, m )),
			qq: cinv(ee[i]),
			s: s +  cliffsimpall(qq | subst(".", "*", df )),
			i:i+1
		),
		if %divsimp=true then (
			/*s:cliffsimpall(s),*/
			if not emptyp(es) then
				s:simpfact(s, es)
		),
		f:s
	),
	s
);

/*
 directional, inner, derivative
*/
invectdiff(f, x, [k] ):=block ([s, n:1, m, i, ee, xx, df, qq, es ],
	[ee, xx]:clicoeff2(x,'list),
	if emptyp(k) then k:1 else k: k[1],
		es: sublist( listofvars(x), lambda ([z], not freeof(asymbol, z))),
	display(es),
	for p:1 thru k do (
		i:1, s:0,
		for m in xx do (
			if mapatom(m) then (
				df: expand(diff( f, m )),
				qq: dotinvsimp(1/ ee[i]),
				s: s +  cliffsimpall(qq | subst(".", "*", df ))
				),
			i:i+1
		),
		s:cliffsimpall(s),
		f:s
	),
	if %divsimp=true then (
		es: sublist( listofvars(x), lambda ([z], not freeof(asymbol, z))),
		s:trigsimp(s),
		if not emptyp(es) then
			s:simpfact(s, es)
	),
	s
);

/*
 interior, dual, vector derivative
*/
intmvectdiff(f, x, [k] ):=block ([s:0, n:1, m, es],
	if emptyp(k) then k:1 else k: k[1],
	x:expand(x),
	for p:1 thru k do (
		s:ctotintdiff(f, x),
		s:cliffsimpall(s),
		f:s
	),
	if %divsimp=true then (
		es: sublist( listofvars(x), lambda ([z], not freeof(asymbol, z))),
		"display(es)",
		s:trigsimp(s),
		if not emptyp(es) then
			s:simpfact(s, es)
	),
	s
);


/*
 exterior, dual, vector derivative
*/
extvectdiff(f, x, [k] ):=block ([s, n:1, m, i, ee, xx, df, qq ],
	[ee, xx]:clicoeff2(x, 'list),
	if emptyp(k) then k:1 else k: k[1],
	for p:1 thru k do (
		i:1, s:0,
		for m in xx do (
			if mapatom(m) then (
				df: expand(diff( f, m )),
				qq: dotinvsimp(1/ ee[i]),
				s: s +  cliffsimpall(qq & subst(".", "*", df))
				),
			i:i+1
		),
		s:cliffsimpall(s),
		f:s
	),
	if %divsimp=true then (
		es: sublist( listofvars(x), lambda ([z], not freeof(asymbol, z))),
		s:trigsimp(s),
		if not emptyp(es) then
			s:simpfact(s, es)
	),
	s
);

/*
 exterior, dual, vector derivative
*/
extvectdiff(f, x, [k] ):=block ([s:0, n:1, m, es],
	if emptyp(k) then k:1 else k: k[1],
	x:expand(x),
	for p:1 thru k do (
		s:ctotextdiff(f, x),
		s:cliffsimpall(s),
		f:s
	),
	if %divsimp=true then (
		"display(es)",
		s:trigsimp(s),
		s:clifact(s)
	),
	s
);

svectdiff(f, x, [k] ):=block ([ df],
	if emptyp(k) then k:1 else k: k[1],
	for p:1 thru k do (
		df:mvectdiff(f, x, p),
		df:scalarpart(df)
		),
	df
);

vvectdiff(f, x, [k] ):=block ([ df],
	if emptyp(k) then k:1 else k: k[1],
	for p:1 thru k do (
		df:mvectdiff(f, x, p),
		df:nscalarpart(df)
		),
	if %divsimp=true then 
			df:clifact(df),
	df
);


/*
 Euler-Lagrange equations
*/

/*
EL  field Lagrangians
*/

ciELfdiff(_F, tt, pvars):=block(
[eq:0, p, pv, ee, qq, ss:[], zz:[],  vv, lv ],
	[p, pv]:pvars,
	if %clverbose=true then
		display(p, pv),	 
	[ee, vv]:clicoeff2(pv, 'list),
	lv: sublist( listofvars(tt), lambda ([z],  freeof(asymbol, z) )),	
	if not mapatom(vv) then
		vv: substinpart("[",vv, 0)
	else vv:[vv],
	for j:1 thru length(vv) do (
		for i:1 thru length(lv) do ( 
			if inop(vv[j])#"+" then (
				push(vv[j]=vv[j](lv[i]), ss),
				push(vv[j](lv[i])=vv[j], zz)
			)
		)
	),
	/*display(ss, zz),*/
	qq:parmvectdiff(_F, pv),
	if %clverbose=true then
		display(qq),
	qq:psubst(ss, qq),
	eq:parmvectdiff(_F, p)-psubst(zz, mvectdiff(qq , tt)),
	clifact(eq)
);

alias (EuLagEq2, ciELfdiff); 


ciELfdiff1(_F, tt, pvars):=block(
[eq:0, p, pv, ee, qq, ss:[], zz:[],  vv, lv, u, ei, mm, vi, tc, qd:0, ec, j:1],
	[p, pv]:pvars,
	if %clverbose=true then
		display(p, pv),	 
	[ee, vv]:clicoeff2(pv, 'list),
	lv: sublist( listofvars(tt), lambda ([z],  freeof(asymbol, z) )),	
	if not mapatom(vv) then
		vv: substinpart("[",vv, 0)
	else vv:[vv],
	for j:1 thru length(vv) do (
		for i:1 thru length(lv) do ( 
			if inop(vv[j])#"+" then (
				push(vv[j]=vv[j](lv[i]), ss),
				push(vv[j](lv[i])=vv[j], zz)
			)
		)
	),	
 
	eq:parmvectdiff(_F, p),
	[ee, lv]:clicoeff2(tt, 'list),
	ei: map(cinv, ee),
	tc: dotconjugate(tt),
	for u in lv do (
		vi: totdiff(p, u),
		qq: ee[j] .parmvectdiff(_F, vi),
		/*qd: qd + (ee[j]. vi) ,
		display(  vi),*/
		qq:psubst(ss, qq),
		mm:  psubst(zz, totdiff(qq , tc @ei[j])).ei[j] ,
		if %clverbose=true then 
			display(qq, mm),
		eq:-dotsimpc(expand(mm))+eq ,
		j:j+1
	),
	clifact(eq)
);

compdiff( _F, vi, vj, tt):=block([df, dx],
	df: _F @ vi,
	dx: tt @ vj,
	/*display(tt, dx, df),*/
	pardiff(df, dx)
);

ciTEM(_F, tt, p):=block(
[   ee, ei, vi, vj, n, ne, vv ],
	ee:cons(1, %elements),
	ne:length(ee),
	n: ndim+1,
	ei: map(cinv, ee), 
	genmatrix( lambda([i,j],  vi:totdiff(p, ei[i] @ tt), vj: totdiff(p, ei[j] @ tt),
		 sum(  (vv:ei[a]@ vi,   if vv#0 then pardiff( _F, vv  )* ( ei[a] @ vj) else 0 ) , a, 1, ne )    )  , 
	n)
);


ciTEM1(_F, tt, p):=block( [ee, ei, n ],
	ee:cons(1, vectors()),
	n: length(ee),
	ei: map(cinv, ee),
	genmatrix( 
		lambda([i,j],  vi:totdiff(p, ei[i] @ tt), vj: totdiff(p, ei[j] @ tt),
			factor( parmvectdirdiff( _F, vj, vi ) ) 
		) , n
	)
);

ciTEM2(_F, tt, pvars):=block([p, pv ],
	[p, pv]:pvars, 
	parmvectdirdiff( _F, pv, pv ) - ndim*_F
);

notsubst(expr, xx, yy, v):=block([f1:0],
	if listp(xx) and listp(yy) then
		for i:1 thru length(xx) do
			f1: f1 + notsubst(expr, xx[i], yy[i], v)
	else (	 
		f1:subst(xx=yy, expr),
		diff(f1, v)
	 )
);
 
/*
 EL particle lagrangians
*/
/*
convective derivative
*/
convderiv(f, t, xx, [vs]):=block( 
	[ lv, n:1, u, nabla:[], lv, ss:0, m, es:[], s:0, ez:[], aa:[], bb:[], cc:[], dd:[], gg:[], rr ],
	if not symbolp(t) then error(t, " must be a symbol"),	
	lv:listofvars(xx),
 	xx:expand(xx),

	[ez, es]: oppart( lv, lambda ([z], freeof(asymbol, z))),
	if not emptyp(vs) then vs:vs[1],
	for j:1 thru length(ez) do (
			push(ez[j]=ez[j](t), aa),
			push(ez[j](t)=ez[j], bb),
			if not emptyp(vs) then (
				rr:arraymake (vs, [ ez[j] ] ),
				push('diff(ez[j](t), t)=rr, cc),
				push(rr=rr(t) , dd),
				push(rr(t)=rr , gg)
			)
		),
	if mapatom(xx) then 
		nabla:[diff( psubst(aa, xx),t)]
	else
		nabla:diff(args(psubst(aa, xx)),t),
	/*display(aa,bb, cc, dd),*/
	if not emptyp(vs) then (
		nabla:psubst(cc, nabla),
		f: psubst(dd, f), 
		display( f)
		),
	ss:pardiff(f, t), 
	n:1, s:0,
	if mapatom(xx) then 
		 xx:[xx],
    for m in xx do (
		s:s+ nabla[n]. ctotdiff(f, m),			
		n:n+1
	),
	disp(nabla),
	ss:ss+s,
	if %divsimp=true then (
			ss:cliffsimpall(ss),
			if not emptyp(es) then
				ss:simpfact(ss, es)
	),
	if not emptyp(gg) then
		ss:psubst(gg, ss),
	ss:psubst(bb, ss),
	clifact(ss)
);


/*
Euler - Lagrange equation derivation
*/

ciEL1(_F, tt, pvars, smat):=block([eq, p, pv, qq, ee, aa:[], bb:[], es:[], ez:[], qp, qq2, cc:[], dd:[] ],
	if not listp(pvars) then error("list required"),
	[p, pv]:pvars,
	eq:parmvectdiff(_F, p),
 	es: sublist( listofvars(p), lambda ([z],  freeof(asymbol, z))),	 
	ez: sublist( listofvars(pv), lambda ([z],  freeof(asymbol, z))),	
	/*display(es, ez), */
	if %clverbose=true then
		display(pv, eq),
	 for j:1 thru length(ez) do (
		push(ez[j]='diff(es[j], tt, 1), aa),
		push('diff(es[j], tt, 1)=ez[j], bb),
		push(ez[j]=ez[j](tt) , cc),
		push(ez[j](tt)=ez[j] , dd)
	),

	qq2: parmvectdiff(_F, pv),
	qq2: subst(cc, qq2),
	display(es, qq2),

	qp: convderiv(qq2, tt, p),
	/* display(qq, qp, ratsimp(qq-qp)), 	*/
	eq:eq - qp,
	eq: psubst(dd, eq),	
	eq: psubst(bb, eq),	
	if smat='list then (
		eq:subst(aa, eq),
		eq: clifact(eq)
	)else if smat='mat then (  		
		eq:bdecompose(eq),
		eq:factorby(eq, ez)
	),
	eq
);
 
ciEL(_F, tt, pvars, smat):=block([eq, p, pv, qq, ee, aa:[], bb:[], es:[], ez:[] ],
	if not listp(pvars) then error("list required"),
	[p, pv]:pvars,
	eq:parmvectdiff(_F, p),
 	es: sublist( listofvars(p), lambda ([z],  freeof(asymbol, z))),	 
	ez: sublist( listofvars(pv), lambda ([z],  freeof(asymbol, z))),	
	/*display(es, ez), */
	if %clverbose=true then
	 display(pv, eq),
	 for j:1 thru length(ez) do (
		push(ez[j]='diff(es[j], tt, 1), aa),
		push('diff(es[j], tt, 1)=ez[j] , bb)
	),
	aa:reverse(aa),
	bb:reverse(bb),
	/*display (aa, bb)
	depends(es, tt),*/
	
	qq: parmvectdiff(_F, pv),
	qq: diff(qq, tt),
	eq:eq - qq,
	if %clverbose=true then
		display(qq),
	eq: psubst(bb, eq),
	/*
	ee:buildq([es], remove(es, dependency)), 
	ev(ee, nouns),
	*/
	if smat='list then (
		eq:subst(aa, eq),
		eq: clifact(eq)
	)else if smat='mat then (  		
		eq:bdecompose(eq),
		eq:factorby(eq, ez)
	),
	eq
);

EL(_F, q, pvars):=block ([eq:0, p, pv, qq, rr, len, ret:[]],
	if not listp(pvars) then error("list required"),
	 len:length(pvars),
	 p:pvars[1],
	 eq:pardiff(_F, p),
	 if len>1 then (
		for i:2 thru len do (
			pv:pvars[i],
			qq: subst('pv(q), pv, pardiff(_F, pv)),
			/*qq: pardiff(_F, pv),*/
			display(qq),
			for j:1 thru i-1 do (
				rr:- convderiv(qq, q, p),				
				rr: subst('diff(p, q)='pv(q), rr),
				display(q, p, pv,  rr),
				eq:eq + subst( pv, 'pv(q), rr  ),
				/*eq:eq+ rr,*/
				qq:rr
			),
			push(pv='diff(pvars[1], q, i-1), ret)
		),
		ret:reverse(ret)
	),
	[ ret, eq]
);



/*
coordinate substitution
*/
coordsubst(rr, eqs):=block( [lv, ret:rr, qq],
	lv: sublist( listofvars(rr), lambda ([z], freeof(asymbol,z))),
	if not listp(eqs) then eqs:[eqs],
	for i:1 thru length(eqs) do (
		if op(eqs[i])="=" then ( 
			qq:rhs(eqs[i]),
			ret:ratsubst(qq,  lhs(eqs[i]), ret)
		) else ( 
			qq:eqs[i],
			ret:ratsubst(qq, lv[i], ret)
			)
	),
	ret:trigsimp(ret),
	ret:ratsimp(ret),
	ret
);

/*   substitution in differnetial equations*/
eqsubst(deq, yv, rr, eqs):=block([rs, qs, ret, lv],
	rs:coordsubst(rr, eqs),
	/*disp(rs),*/
	
	/* dependent variable*/
	ret:rs @ mvectdiff(yv, rr),
	ret:trigsimp(ret),
	ret:ratsimp(ret),
	
	qs:cdirdiff(yv, rr, rs),
	qs:subst(eqs, qs),	
	qs:trigsimp(qs),
	qs:ratsimp(qs),
	
	lv:listofvars(maplist(rhs, eqs)),
	/*disp(lv),*/
	lv:solve(eqs, lv),
	ret:subst(lv, ret),
	rs: ratsubst( qs, ret, deq),
	[rs, ret=qs, lv]
); 

/*
volume element
coordinate substitution
*/

volel(eqs, [lv]):=block( [ ret, qq:[] ],
	if not listp(eqs) then eqs:[eqs],
	if not emptyp(lv) then (
		lv:lv[1],
		for i:1 thru length(eqs) do
			push(rhs(eqs[i]), qq)  
	) else (
		for i:1 thru length(eqs) do (
		 lv: append( sublist( listofvars(rhs(eqs[i])), lambda ([z], freeof(asymbol,z))), lv),
			  push(rhs(eqs[i]), qq)  
			  ), 
		lv:unique (lv)
	  ),
	   qq:reverse(qq),
	   /*disp(qq, lv),*/
	   /*  jacobian computation*/
	ret: outermap (lambda([u,z], diff(qq[z], u)),  lv, makelist(i,i, length(lv))),
	ret: substinpart('matrix, ret,0),
	if %clverbose=true then display(lv, qq, ret),
	ret:determinant(ret),
	if %divsimp=true then (
		ret:trigsimp(ret),
		ret:ratsimp(ret)
	),
	%iv.ret
);

clidet(vlist):=block([dd, n ],
	n:length(vlist),
	dd:vlist[1], 
	for i:2 thru n do (
		dd:dotsimpc(dd & vlist[i]),
		if dd=0 then return(dd)
	),
	factorby(dd, %iv)
);

clivolel(rr, eqs, [lv]):=block([ ret, qq:[], rq, z ],
	if not listp(eqs) then eqs:[eqs],
	if not emptyp(lv) then (
		lv:lv[1],
		for i:1 thru length(eqs) do
			push(rhs(eqs[i]), qq)  
	) else (
	 for i:1 thru length(eqs) do (
		 lv: append ( sublist( listofvars(rhs(eqs[i])), lambda ([z], freeof(asymbol,z))), lv),
		  push(rhs(eqs[i]), qq)  
		  ), 
	  lv:unique (lv)
	  ),
	  rq:subst(eqs,rr),
	ret:map (lambda([z], diff(rq, z)),  lv ),
	if %clverbose=true then display(lv, qq, ret),
	ret:clidet(ret),
	if %divsimp=true then (
		ret:trigsimp(ret),
		ret:ratsimp(ret)
	),
	ret
);


put('cliffordan, 'v17,'version);
put('cliffordan, "Dimiter Prodanov", 'author);
put('cliffordan, "(C) - Dimiter Prodanov, 2015", 'copyright);

print("package name: cliffordan.mac");
print("author: ", get('cliffordan,'author));
print("version:", get('cliffordan,'version));
print("Recommended location: share/contrib");
print("last update: 23 Aug 2017");