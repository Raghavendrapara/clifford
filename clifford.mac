/*******************************
Clifford algebra
a lightweight package for performing Geometric Algebra calculations

 v 1.0 
**********************************
 * @license This library is free software; you can redistribute it and/or
 *      modify it under the terms of the GNU Lesser General Public
 *      License as published by the Free Software Foundation; either
 *      version 2.1 of the License, or (at your option) any later version.
 *
 *      This library is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *       Lesser General Public License for more details.
 *
 *      You should have received a copy of the GNU Lesser General Public
 *      License along with this library; if not, write to the Free Software
 *      Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
matchdeclare(aa, lambda([u], not freeof(asymbol,u)), [bb,cc], all, [kk, mm, nn], integerp);
"vector symbol";
asymbol:e;
"number of dimensions";
ndim:0;
signature:[];
esignature:[];
"pseudoscalar";
%iv:1;
_debug:false;
dotexptsimp :false;
noundisp :true;
dotscrules:true;
powerdisp:true;

(	
	"outer product",
	infix ("&", 130, 129),
	"&"(a, b):=expand((a.b - b.a)/2),
	texput ("&", " \\Lambda ", infix)
);
 
dotsimp1(ab):=block([a, b],
  if atom(ab) or op(ab)#"." then return(ab),
  a:part(ab,1),
  b:part(ab,2),
 if orderlessp(a,b) then -b.a else ab
);

dotsimp2(ab):=block([a, b],
  if atom(ab) or op(ab)#"." then return(ab),
  a:part(ab,1),
  b:part(ab,2),
 if ordergreatp(a,b) then -b.a else ab
);

toggle_debug():= _debug: not _debug;

declare (dotsimpc, evfun);
dotsimpc(ab):=block([ba, c:1, v, len, w:1, q],
  if atom(ab) or freeof(".", ab) or op(ab)="+"  then return(ab),
  ba:copy(ab),
  if op(ba)="-" then ( 
	w:-1,
	ba:-ba
  ),
  v:args(ba),
  if _debug=true then print("op ", op(ba), "v ", v),
  "len:length(v)",
  w:w*permsign(v),
  v:sort(v),
  for q in v do
    c:c.q,
 if _debug=true then  print(w, v),
  w*c 
);

matchdeclare(dd, lambda([u],  freeof(asymbol,u)));
defrule (clifsimp1, dd*aa, dd*dotsimpc(aa));
defrule (clifsimp3, dd*aa, scprodsimp(dd*aa));
defrule (clifsimp10, aa, dotsimpc(aa));
defrule (clifsimp2, dd/aa, dd*dotinvsimp(1/aa));
/*
defrule (clifrev, dd*aa, dd*dotreverse(aa));
defrule (clifrev1, aa, dotreverse(aa));
*/

declare (cliffsimpall, evfun);
cliffsimpall(expr):=block([res],
	res:expand(expr),
	res:apply1(res, clifsimp2, clifsimp1, clifsimp10),
	ratsimp(res)
);

cliffsimp1(expr):=block([res],
	res:expand(expr),
	apply1(res, clifsimp1, clifsimp10)
);

permsign(arr):=block([k:0, len] ,
	if not listp(arr) then return (false),
	len:length(arr),
	for i:1 thru len do
		for j:i+1 thru len do
			if ordergreatp(arr[i], arr[j]) then k:k+1,
	if evenp(k) then 1 else -1
);


declare (dotinvsimp, evfun);
dotinvsimp(ab):=block( [a,b,s],
 if atom(ab) or freeof(asymbol, ab) or op(ab)#"/" then return(ab),
  a:part(ab,1),
  b:part(ab,2),
  s: expand(b.b),
  if not freeof(asymbol, s) then  s:cliffsimp1(s),
  if s#0 then a.b/s else ab 
);

cinv(ab):=block( [s, b],
 if atom(ab) or freeof(asymbol, ab) then return(1/ab),
  b:cconjugate(ab),
  s:expand(ab.b),
  if not freeof(asymbol, s) then  s:cliffsimpall(s),
  if s#0 then b/s else 'nan
);

powsimp(aa):=block( [a,k,p],
  if atom(aa)   then return(aa),
  if op(aa)="^^" or op(aa)="^" then (
	  a:inpart(aa,1),
	  k:inpart(aa,2),
	  p:inpart(a,1),
	  if _debug=true then print(a,k,p),
	  if not integerp(k) then return(aa),
	  if evenp(k) then 
	  aform[p,p]^fix(k/2) 
  else  aform[p,p]^fix(k/2)*a )
  else aa
 );

declare (scprodsimp, evfun);
scprodsimp(ab):=block([ba, c, v:[], len, w:1],
  if atom(ab) or freeof(".", ab) then return(ab),
  ba:copy(ab),
  v:partition(ba, "."),
  expand(v[1].v[2]+v[2].v[1])/2
);
 
/* simplification rules
*/
if get('clifford,'version)=false then (
	tellsimp(aa[kk].aa[kk], aform[kk,kk] ),
	tellsimpafter(asymbol[mm]*asymbol[nn], aform[mm,nn] ),
	tellsimpafter(asymbol[mm]*asymbol[nn]*cc, aform[mm,nn]*cc ),
	tellsimp(bb.aa[kk].aa[kk].cc, bb.aform[kk,kk].cc),
	tellsimpafter(aa[kk]^^nn, powsimp(aa[kk]^^nn)),
	tellsimpafter(aa[kk]^nn, powsimp(aa[kk]^nn)),
	tellsimpafter(aa[kk].aa[mm], dotsimp2(aa[kk].aa[mm]))
); 

clifford(var, p,n,r):=block([m:p+r+n, a, lst],
	if not (numberp(n) or numberp(p) or numberp(r)) then error(" provide numbers"),
	if m<=0 then return (false),
	local (a),
	a[i,j]:= if i#j then 0 else (
		if i<=p then 1 else if i>n+p then 0 else -1
	),
	ndim:m,
	makebasis(var),
	signature:makelist(a[i,i], i, m),
	%iv:pscalar(),
	aform:genmatrix (a, m, m) 
);

set_signature(arr):=block(
	if not listp(arr) or length(arr)#ndim then return(false),
	signature:arr,
	for i:1 thru ndim do
		aform[i,i]:arr[i]
);

makebasis( var):= block([ ee], 
	asymbol: var,
	ee:buildq([asymbol], array(asymbol, ndim)), 
	ev(ee,nons)
);


pscalar():=block([s:1],
	for i:1 thru ndim do s:s.asymbol[i],
	s
);

release():=block(
	remrule ("^^",  all),
	remrule ("^",  all),
	remrule (".",  all),
	remrule ("*",  all),
	rem('clifford,'version),
	rem('clifford,'author),
	rem('clifford,'copyright)
);

grade(expr):=block([c, v, k, r, l, s, err],
	if atom(expr) or (op(expr)=asymbol and freeof(".", expr)) then return([expr]),
	if op(expr)#"+" and op(expr)#"*" then return(false),
	local(c),
	array(c, fixnum, ndim),
	if op(expr)="." then (
		k:length(expr),
		c[k]:expr
	) elseif op(expr)="*" then (
		s:part(expr,1), l:rest(expr,1),
		if _debug=true then print( s, l),
		k:length(l),
		c[k]:s*l
	) else (
		v:args(expr),
		if _debug=true then print(v),
		for i:1 thru length(v) do (
			if not freeof(".", v[i]) then (
				if _debug=true then print(v[i]),
				if freeof("*", v[i]) then (
					k:length(v[i]),
					c[k]:c[k]+v[i]
				) else (				
					[l,r]:partition(v[i], "."),
					if _debug=true then print( l, r),
					s:args(r),
					k:length(s),
					c[k]:c[k]+v[i]
				)
			) else 
				if freeof(asymbol, v[i]) then 
					c[0]:c[0]+v[i]
				else 
					c[1]:c[1]+v[i]
		)
	),
	listarray(c)
);

ctranspose(x):=block ([l, v:0, len, k],
	if not freeof(".",x) then 
		l:grade(expand(x))
	else 
		l:grade(x),
	len: length(l),
	for i:1 thru len do (
		k:mod(i-1,4), 
		k: (if k<2 then 1 else -1),
		v:v+ k * l[i] 
	),
	v
);

creverse(x):=block ([l, v:0, len, k, a,b],
	if not freeof(".",x) then 
		l:grade(expand(x))
	else 
		l:grade(x),
	len: length(l),
	for i:1 thru len do (
		if not freeof(".",l[i]) then (
			[a, b]: partition(l[i], "."),
			b:reverse(b),
			v:v+ a*b )
		else  v:v +l[i]
	),
	v
);


dotreverse(ab):=block([a, b],
  if atom(ab) or op(ab)#"." then return(ab),
  a:part(ab,1),
  b:rest(ab,1),
  if _debug=true then print(a,b),
  dotreverse(b). dotreverse(a)
);

ccinvolve(x):=block ([l, v:0, len, k],
	if not freeof(".",x) then 
		l:grade(expand(x))
	else 
		l:grade(x),
	len: length(l),
	for i:1 thru len do (
		k:mod(i-1,4), 
		k: (if k=0 or k=2 then 1 else -1),
		v:v+ k * l[i] 
	),
	v
);

cconjugate(x):=block ([l, v:0, len, k],
	if not freeof(".",x) then 
		l: grade(expand(x))
	else 
		l:grade(x),
	len: length(l),
	for i:1 thru len do (
		k:mod(i-1,4), 
		k: (if k=1 or k=2 then -1 else 1),
		v:v+ k * l[i] 
	),
	v
);

elements():=block([c:1, l:[], r:[], len ],
	for i:1 thru ndim do c:c.(1+ asymbol[i] ),
	c:expand (c),
	l:grade(c),
	if l#false then (
		len: length(l),
		for j:2 thru len do  
			if op(l[j])="+" then 
				r:append(r, sort(args(l[j])))
			else
				r:endcons(l[j], r)
	),
	r
);

mtable2():=block([n, a, lst],
	local (a, M),
	lst: elements(),
	lst:cons(1,lst),
	n:length(lst),
	if _debug then 
	a[i,j]:= (lst[i].lst[j]) else
		a[i,j]:= dotsimpc(lst[i].lst[j]),
	genmatrix(a,n,n)
);

mtable1():=block([n, a, lst],
	local (a, M),
	lst: makelist(asymbol[i], i, ndim),
	lst:cons(1,lst),
	n:length(lst),
	a[i,j]:= dotsimpc(lst[i].lst[j]),
	genmatrix(a,n,n)
);

cliabs(x):=block([u:expand(x)],
 u:expand(u*cconjugate(u)),
 u:sqrt(u),
 radcan(u)
);

multtrace():=block([s:[1], lst],
	lst:elements(),
	lst:cons(1, lst),
	for i:1 thru length(lst) do 
		s:endcons(dotsimpc(lst[i].lst[i]),  s),
	s
);


cnorm(x):=block([u:expand(x), z, v],
 u:expand(u. cconjugate(u)),
 u:cliffsimpall(u),
 u:ratsimp(u)
);
 


/*

defrule(csubst2, bb*asymbol[kk], sqrt(aform[kk,kk])*bb);
*/
defrule(csubst, bb*asymbol[kk], aform[kk,kk]*bb);
psnorm(x):=block([u:expand(x), z, v],
	if atom(x) then return (x*x),
	if op(u)="+" then ( 
		v:args(u),
		v:sort(v),
		z:apply1(v,csubst),
		u:z.z,
		ratsimp(u)
	) else (
		z:apply1(u,csubst),
		u:z.z,
		ratsimp(u)
	)	
);

/**
 grading functions
*/
scalarpart(v):=block([gr],
	gr:grade(v),
	gr[1]
);

vectorpart(v):=block([gr],
	gr:grade(v),
	gr[2]
);

grpart(v,k):=block([gr],
	if k>ndim+1 then k:ndim+1,
	gr:grade(v),
	gr[k]
);

/**
 application functions
*/

dual(x):=x/%iv;

project(a, v):=block ([ n: v/cliabs(v)] ,
	cliffsimpall(n.(a*n))
);

reject(a, v):=block ([ n: v/cliabs(v)] ,
	cliffsimpall(n.(n & a))
);

reflect(a, v):=block ([ n: v/cliabs(v)] ,
	cliffsimpall(n.a.n)
);

idemp2(k,j):=block(
	if k>ndim or j>ndim then return(false),
	if signature[k]*signature[j] <0 then
	[ (1 +asymbol[k]. asymbol[j])/2, (1 -asymbol[k]. asymbol[j])/2]
	else [1]
);

idemp(k):=block(
	if k>ndim   then return(false),
	if signature[k] >0 then
	[(1 +asymbol[k])/2, (1 -asymbol[k])/2]
	else [1]
);
cvect(x):=sum (x[i]*asymbol[i], i, 1, ndim);

celem(x):=block([ee:elements(), n],
	ee:cons(1,ee),
	n:length(ee),
	sum (x[i]*ee[i], i, 1, n)
);

scdiff( f, x, k, n):= asymbol[k]*diff(f,x,n);
scdiff1( f, x, k):= asymbol[k]*diff(f,x);
vdiff( f, x, k, n):= asymbol[k] & diff(f,x,n);
vdiff1( f, x, k):= asymbol[k] & diff(f,x);

vectdiff(f,x):=block ([s, n:ndim, ee ],
	if listp(x) then n:length(x),
	if n>ndim then error("size mismatch"),
	s:sum(dotinvsimp(1/asymbol[i]). (diff( f, x[i] )), i, 1, n),
	s:expand(s),
	cliffsimpall(s)
);


put('clifford, 'v1,'version);
put('clifford, "Dimiter Prodanov", 'author);
put('clifford, "(C) - Dimiter Prodanov, 2015", 'copyright);