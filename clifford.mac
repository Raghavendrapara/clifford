/*******************************
Clifford algebra
a lightweight package for performing Geometric Algebra calculations

 v 	1.7 Date 18 nov 2015
        - refactoring
	- change in grade
	- chage in simp rules

	1.6 Date 04 Nov 2015
	- bugixes oppart
	- unit tests

	1.5.1 Date 30 Oct 2015
	- bugfixes oppart

	1.4 Date 22 Aug 2015
	- oppart simplified

	1.3 Date 11 Jun 2015
**********************************
 * @license This library is free software; you can redistribute it and/or
 *      modify it under the terms of the GNU Lesser General Public
 *      License as published by the Free Software Foundation; either
 *      version 2.1 of the License, or (at your option) any later version.
 *
 *      This library is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *       Lesser General Public License for more details.
 *
 *      You should have received a copy of the GNU Lesser General Public
 *      License along with this library; if not, write to the Free Software
 *      Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 matchdeclare([aa, ee], lambda([u], not freeof(asymbol,u)), [bb,cc], true, [kk, mm, nn], integerp);
 
"vector symbol";
asymbol:e;
"number of dimensions";
ndim:0;
signature:[];
"pseudoscalar";
%iv:1;
"squre of pseudoscalar";
%ivnorm:1;
"elements of the algebra";
%elements:[1];

_debug:false;
dotexptsimp :false;
noundisp :true;
dotscrules:true;
powerdisp:true;
dotconstrules:false;
prederror :false;

/*
 custom operators
*/
(
	"innter product",
	infix ("~", 130, 129),
	"~"(a, b):= if scalarp(a) and scalarp(b) then a*b else expand((a.b + b.a)/2),
	texput ("~", " \\circ ", infix),

	"outer product",
	infix ("&", 130, 129),
	"&"(a, b):=if scalarp(a) and scalarp(b) then 0 else expand((a.b - b.a)/2),
	texput ("&", " \\wedge ", infix)
);



inop(expr):= if not mapatom (expr)  then 
	inpart(expr, 0)
	else 'nil;

inargs(expr):= if not mapatom (expr)  then  substinpart( "[", expr, 0) else 'nil;

/*
partition by predicate with expression reconstruction
literal meaning
*/
oppart(expr, predf):=block(
	[sop, lst, lsttrue:[], lstfalse:[], ltrue, lfalse, err ],
	mode_declare([lsttrue, lstfalse, lst, err], list),
	if mapatom(expr) then (
		if apply(predf,[expr]) then (ltrue:expr, lfalse:'nil)
		else (lfalse:expr, ltrue:'nil),
		return( [ltrue, lfalse])
	) else (
		sop:inop(expr),
		expr:rest(expr, 0),
		lst: inargs(expr),
		if _debug=true then display( sop, lst), 
		for v in lst do (
			if apply(predf, [v]) then push(v, lsttrue) 
			else push(v, lstfalse)
		),
		lsttrue:reverse(lsttrue),
		lstfalse:reverse(lstfalse),
		if _debug=true then display(lsttrue, lstfalse),  
		err:errcatch (
			ltrue:if not emptyp(lsttrue) then 
				substinpart(sop, lsttrue, 0) 
				else  'nil,
			lfalse:if not emptyp(lstfalse) then 
				substinpart(sop, lstfalse, 0) 
				else  'nil,
		 	if _debug=true then display( ltrue, lfalse), 
			lst:[ ltrue, lfalse]
		),
		if emptyp(err) then lst([expr, 'nil])
	),
	lst
);
  

/* 
extaracts equivalence information from the facts database
*/ 
iseq(x):= block([ vv, nil, inflag:true], 
	mode_declare(vv, list), 
	vv:sublist(facts(x), lambda([u], not freeof('equal , u ))),
	if not emptyp(vv) then (
		vv:map(lambda([u],   inpart(u,1,1)=inpart(u,2)- (inpart(u,1) -inpart(u,1,1)) ), vv),
		vv[1]
	) else nil 
);

/* 
declares equivalence  
*/ 
eqassume(st):=block([simp:false, ll:lhs(st), rr:rhs(st) ] ,
	if equal(ll,rr)#true then
	assume(equal(ll,rr)) else 'done
);

/* 
substitutes equivalences
*/
declare (eqsubst, evfun);

eqsubst( eq):=block( [aa, ss, sop, lst],
	mode_declare(lst, list), 
	sop: inop(eq),
	if sop = 'nil then (
		aa:iseq(eq),
		if aa#'nil then ss:ratsubst(rhs(aa), lhs(aa), eq)
	) else (
		ss: factor(eq),
		lst: inargs(ss),
		for x in lst do (
			aa:iseq(x),
			if aa#'nil then ss:ratsubst(rhs(aa), lhs(aa), ss)
		)
	),
	ss
);
/*
eqsubst( eq):=block( [aa, ss, sop, zz, quot],
	sop: inop(eq),
	if sop = 'nil then (
		aa:iseq(eq),
		if aa#'nil then (
			zz:lhs(aa)-rhs(aa),
			[quot, ss]:divide(eq, zz),
			"display(zz, ss)"
		) else ss: eq
	) else(
		ss:map(eqsubst, eq)
	),
	ss
);
*/
/* 
simplifies based on equivalences
*/
doteqsimp(expr):=block([ gr:grade(expr)],
	gr:map(factor, gr),
	gr:map(eqsubst, gr),
	substinpart("+", gr, 0)
);

 
realp (x):= featurep(x, real);

/*
simplification of dot-products, ordergreat
*/
dotsimp1(ab):=block([a, b],
  if atom(ab) or op(ab)#"." then return(ab),
  a:inpart(ab,1),
  b:inpart(ab,2),
 if orderlessp(a,b) then -b.a else ab
);

/*
simplification of dot-products, orderless
*/
dotsimp2(ab):=block([a, b],
  if atom(ab) or op(ab)#"." then return(ab),
  a:inpart(ab,1),
  b:inpart(ab,2),
  if ordergreatp(a,b) then -b.a else ab
);

/*
toggles debugging
*/
toggle_debug():= _debug: not _debug;

/*
simplification of dot-products
*/
declare (dotsimpc, evfun);
dotsimpc(ab):=block([ba, c:1, v, w:1, q, r, l, sop],
  mode_declare(w, fixnum),
  mode_declare([r,l], any),
  sop:inop(ab),
  if mapatom(ab) or freeof(".", ab) or sop='nil or op(ab) ="/" then return(ab),
  
  if sop="+" then 
	map(dotsimpc, ab)
  else if sop="*" then (
    [r,l]: oppart(ab, lambda([u], freeof(".", u))),
	r*dotsimpc(l)
  ) else (
	 ba:copy(ab),
	 v:inargs(ba),
	 if _debug=true then display(sop, v),
	 w:permsign(v),
	 v:sort(v),
	 for q in v do c:c.q,
	 if _debug=true then  display(w, v),
	 w*c
  )
);




/*
internal function: parity of permutation calculation
*/
permsign(arr):=block([k:0, len] ,
	mode_declare([k, len], fixnum),
	if not listp(arr) then return (false),
	len:length(arr),
	for i:1 thru len do
		for j:i+1 thru len do
			if ordergreatp(arr[i], arr[j]) then k:k+1,
	if evenp(k) then 1 else -1
);



/*
simplification rules
*/
matchdeclare(dd, lambda([u],  freeof(asymbol, u)), rr, realp);
defrule (clifsimp1, dd*aa, dd.dotsimpc(aa));
defrule (clifsimp11, bb.aa, bb.dotsimpc(aa));
defrule (clifsimp10, aa, dotsimpc(aa));
defrule (clifsimp2, dd/aa, dd * dotinvsimp(1/aa));
defrule (clifsimp21, bb/aa, bb . dotinvsimp(1/aa));



/*
full simplification of expressions
*/
declare (cliffsimpall, evfun);
cliffsimpall(expr):=block([res, aa, bb, sop],
	sop:inop(expr),
	if equal(sop, "=") then (
		aa:cliffsimpall(lhs(expr)),
		bb:cliffsimpall(rhs(expr)),
		return( aa= bb)
	) else (
		res:expand(expr),
		res:apply1(res, clifsimp21, clifsimp2),
		res:apply1(res,  clifsimp10, clifsimp1),
		ratsimp(res)
	)
);

/*
simplification of dot-products
*/
cliffsimp1(expr):=block([res],
	res:expand(expr),
	apply1(res, clifsimp1, clifsimp10)
);


/*
 simplification of inverses
*/
declare (dotinvsimp, evfun);
dotinvsimp(ab):=block( [a,b,s],
 mode_declare([a,b,s], any),
 if mapatom(ab) or freeof(asymbol, ab) or op(ab)#"/" then return(ab),
  a:part(ab,1),
  b:part(ab,2),
  s: expand(b.b),
  if not freeof(asymbol, s) then  s:cliffsimp1(s),
  if s#0 then a.b/s else ab 
);


/*
Clifford inverse
*/
cinv(ab):=block( [s, b, u:1],
 if atom(ab) or freeof(asymbol, ab) then return(1/ab),
  b:cconjugate(ab),
  s:expand(b.ab),
  if not freeof(asymbol, s) then s: apply1(s, clifsimp10, clifsimp2),
  display(s),
  /*
  if s-scalarpart(s)#0 then ( 
	u:creverse(s),
	s:expand(s.u),
	s: apply1(s, clifsimp10),
	print(s)
  ),*/
  if s#0 then (
	b:expand(b.u),
	b:apply1(b, clifsimp10),
	return(b/s)
  )else return(1/ab)
);


/*
simplification of exponents
*/
powsimp(aa):=block( [a,k,p],
  if atom(aa) then return(aa),
  if op(aa)="^^" or op(aa)="^" then (
	  a:inpart(aa,1),
	  k:inpart(aa,2),
	  p:inpart(a,1),
	  if _debug=true then print(a,k,p),
	  if not integerp(k) then return(aa),
	  if evenp(k) then 
	  signature[p]^fix(k/2) 
  else  signature[p]^fix(k/2)*a )
  else aa
 );



if get('clifford,'version)=false then (
	tellsimp(aa[kk].aa[kk], signature[kk] ),
	tellsimpafter(aa[kk].aa[mm], dotsimp2(aa[kk].aa[mm])),
	/*tellsimpafter(bb.aa.cc, apply1(bb.aa.cc, clifsimp10)),*/
	tellsimpafter(bb.ee.cc, dotsimpc(bb.ee.cc)),
	tellsimpafter(aa[kk]^nn, powsimp(aa[kk]^nn)),
	tellsimpafter(aa[kk]^^nn, powsimp(aa[kk]^^nn))
);

/*
constructor of the algebra
lsig[1] - number of positive elements
lsig[2] - number of negative elements
lsig[3] - number of positive elements
lsig[4] - sets signature
*/
clifford(var, [lsig]):=block([m, a, p:0, n:0, r:0, s:1],
	if emptyp(lsig) or length(lsig)>3 then error(" invalid signature"),
	p:lsig[1],
	if length(lsig)=2 then 
		n:lsig[2],
	if length(lsig)=3 then (
		n:lsig[2], 
		r:lsig[3]
	),
	/* optinally we can reverse the sign convention */
	if length(lsig)=4 then (
		n:lsig[2], 
		r:lsig[3],
		s: signum (lsig[4]),
		if s=0 then s:1
	),
	if not (numberp(n) or numberp(p) or numberp(r) or numberp(s) ) then error(" provide numbers"),
	m:p+r+n,
	if _debug=true then print(m,p,n,r),
	if m<=0 then return (false),
	
	local (a),
	a[i,j]:= if i#j then 0 else (
		if i<=p then s else if i>n+p then 0 else -s
	),
	ndim:m,
	makebasis(var),
	signature:makelist(a[i,i], i, m),
	%iv:pscalar(),
	aform:genmatrix (a, m, m),
	%ivnorm:dotsimpc(%iv.%iv),
	%elements:elements(),
	signature
);


/*
sets the signature of the algebra
*/
set_signature(arr):=block(
	if not listp(arr) or length(arr)#ndim then return(false),
	signature:arr,
	for i:1 thru ndim do
		aform[i,i]:arr[i],
	%iv:pscalar(),
	%ivnorm:dotsimpc(%iv.%iv),
	aform
);

/*
toggles the signature of the algebra
*/
toggle_signature():=block(
	signature:-signature,
	aform:-aform,
	%iv:pscalar(),
	%ivnorm:dotsimpc(%iv.%iv)
);

/*
constructs the complete basis of the algebra
- additional declarations added for compatibility with complex 
operations
*/
makebasis(var):= block([ ee], 
	asymbol: var,
	ee:buildq([asymbol], declare(asymbol, real)), 
	ev(ee,nouns),
	ee:buildq([asymbol], declare(asymbol, mainvar)), 
	ev(ee,nouns),
	ee:buildq([asymbol], array(asymbol, ndim)	), 
	ev(ee,nouns)
);

/*
constructs the pseudoscalar of the algebra
*/
pscalar():=block([s:1],
	for i:1 thru ndim do s:s.asymbol[i],
	s
);

/*
releases all rules 
*/
release():=block(
	remrule ("^^",  all),
	remrule ("^",  all),
	remrule (".",  all),
	remrule ("*",  all),
	remrule ("/",  all),
	rem('clifford,'version),
	rem('clifford,'author),
	rem('clifford,'copyright)
);

clidecode(ab):=block([r, l, aa, ret],
  [l, r]: oppart(ab, lambda([u], freeof(asymbol, u))),
  if l#nil then l: signum(l) else l:1,
  if r#'nil then (
	r:dotsimpc(r),
	if not freeof(".", r) then (
		r:maplist(lambda([u], aa:args(u), 2^aa[1]), r),
		ret:l*(substinpart("+", r, 0))
	) else (
		aa:args(r), 
		ret: l*2^aa[1]
	)
 ) else ret:1,
 ret
);



/*
counts occurences of a symbol in an expression
*/
countsym(ab, sym):=block([sop, a, b, s:0, inflag:true ],
	if freeof(sym, ab) then return(0),
	if atom(ab) then  
		if sym=ab then return(1),
	if subvarp(ab) then  
		if sym=op(ab) then return(1),
 
	sop:inop(ab),	 
	if _debug=true then display(sop),
	if member(sop, ["+", "*","."]) then (
		a: part(ab, 1),
		b: rest (ab, 1),
		if _debug=true then display(a,b),
		s:s+ countsym(a, sym)+ countsym(b, sym)
	),
	s
);

/*
grade decomposition of expressions
 new implementation
 */
grade(expr):=block([c, sop, k],
	local(c),
	array(c, fixnum, ndim),
	if not mapatom(expr) then 
		expr:expand(expr),
	sop: inop(expr),
	if sop="+" then (
		for v in expr do (
			k:countsym(v, asymbol),
			if _debug=true then display(k,v),
			c[k]:c[k] +v 
		)
	)else ( "simple expression",
		k:countsym(expr, asymbol),
		c[k]:c[k] +expr 
	),
	listarray(c)
);

/*
 Partial factoring by subexpression
*/
factorby(expr, z):=block([quot, res, ret ],
	if not listp(z) then (
		[quot, res]:divide(expr, z),
		ret:factor(quot)*z+factor(res) 
	) else (
		[quot, res]:divide(expr, z[1]),
		if length(z)>1 then
			res:factorby(res, rest(z)),
		ret:factor(quot)*z[1]+res
	),
	ret
);
 
/*
computes the element decomposition
*/
clicoeff(expr, smat):=block([c, ee, sop,  r, l,  lst ],
	local(c, ee),
	c:make_array(hashed, 2^ndim),
	ee:make_array(hashed, 2^ndim),
	if not mapatom(expr) then 
		expr:expand(expr),
	if emptyp(%elements) then 
		%elements:elements(),
	expr:factorby(expr, %elements),
	sop: inop(expr),
	if sop="+" then (
		lst: inargs( (expr)),
		for v in lst do (				 
			if _debug=true then  display(  v),
			if freeof (asymbol, v ) then (
				if c[1]=false  then c[1]:v else
				c[1]:c[1]+v,
				if ee[1]=false  then ee[1]:1
			) else (
				[l,r]: oppart (v, lambda ([u], freeof(asymbol, u))),
				if _debug=true then display(r,l),
				if c[r]=false  then c[r]:l else
				c[r]:c[r] +l,
				if ee[r]=false  then ee[r]:r
			)
		)
	)else ( "simple expression, separate",
		 if freeof (asymbol, expr ) then (
			c[1]:expr, 
			if expr#0 then
			ee[1]:1 else ee[1]:0
		)else (
			[l,r]: oppart (expr, lambda ([u], freeof(asymbol, u))),
			if _debug=true then display(r,l),
			c[ r]:subst('nil=1, l),
			ee[ r]:r
		 )
	),
	lst:listarray(c),
	if smat='list then 
		[listarray(ee), lst]	
	else if smat='mat then  
		[listarray(ee), transpose(matrix(lst))]
);

/*
computes the blade decomposition
*/
bdecompose(expr):=block([gr],
	if not freeof(".", expr) then 
		gr: expand(expr),
	gr:grade(gr),
	map(lambda([z], clicoeff(z, 'mat)),gr)
);

/*
Clifford reverse of expressions
*/
creverse(x):=block ([l, v:0, len, k],
	if not freeof(".",x) then 
		l:grade(expand(x))
	else 
		l:grade(x),
	len: length(l),
	for i:1 thru len do (
		k:mod(i-1,4), 
		k: (if k=0 or k=1 then 1 else -1),
		v:v+ k * l[i] 
	),
	v
);


/*
Clifford involution of expressions
*/
cinvolve(x):=block ( [ret],
	if not freeof(".",x) then 
		ret: expand(x) 
	else ret:x,
	subst(asymbol=lambda([k], - subvar (asymbol, k) ), ret)
);

/*
Clifford conjugate of expressions
*/
cconjugate(x):=block ([l, v:0, len, k],
	if not freeof(".",x) then 
		l: grade(expand(x))
	else 
		l:grade(x),
	len: length(l),
	for i:1 thru len do (
		k:mod(i-1,4), 
		k: (if k=1 or k=2 then -1 else 1),
		v:v+ k * l[i] 
	),
	v
);


/*
constructs all  irreducible elements of the algebra,
optionally includes 1
*/
elements([cpl]):=block([c:1, lst:[] ],
	for i:1 thru ndim do c:c.(1+ asymbol[i] ),
	if emptyp(cpl) then cpl:true 
	else cpl:false,
	c:expand(c),
	lst:inargs(c),
	if cpl then pop(lst),
	sort(lst, lambda([u,v], 
			ordergreatp(u,v) and if not (numberp(u) or numberp(v)) then length(u)< length(v)
			)
	)
);



/**
 multiplication table, all elements
*/
mtable2():=block([n, a, lst],
	local (a),
	lst: elements(all),
	n:length(lst),
	if _debug then 
	a[i,j]:= (lst[i].lst[j]) else
		a[i,j]:= dotsimpc(lst[i].lst[j]),
	genmatrix(a,n)
);

/**
 multiplication table, reduced

*/
mtable1([lst]):=block([n, a],
	local (a),
	if emptyp(lst) then 
		lst:makelist(asymbol[i], i, ndim) 
	else 
		lst:lst[1],
	lst:push(1,lst),
	n:length(lst),
	a[i,j]:= dotsimpc(lst[i].lst[j]),
	genmatrix(a,n)
);

mtable3(vlst, v):=block([lst],
	lst:maplist(lambda([u], dotsimpc(dotinvsimp (v).u)), vlst ),
	disp(lst),
	mtable1(lst)
);
 
/*
 computes the commutation table with all basis vectors
*/
commtable(ee):=
	matrix(makelist(asymbol[i], i, 1, ndim), 
		  makelist( cliffsimpall ( asymbol[i]. ee - ee. asymbol[i])/2, i, 1, ndim)
		  );

/**
 norm
*/
cliabs(x):=block([u:expand(x)],
	u:expand(u.cconjugate(u)),
	u:scalarpart(u),
	u:sqrt(abs(u)),
	radcan(u)
);


/**
 scalar product
*/
scprod(x, y):=block([u:expand(x), v:expand(y)],
	u:expand(creverse(u).v),
	u:scalarpart(u),
	u:sqrt(u),
	radcan(u)
);

/**
 multiplication table, trace
*/
multtrace():=block([s:[1], lst],
	lst:elements(all),
	for i:1 thru length(lst) do 
		s:endcons(dotsimpc(lst[i].lst[i]), s),
	s
);

cnorm(x):=block([u:expand(x), z, v],
	u:expand(u. cconjugate(u)),
	u:cliffsimpall(u),
	if not freeof (".", u) then 
		error ("not free of non-scalars "),
	u:scalarpart(u),
	u:ratsimp(u)
);
	
/**
norm^2, experimental

 */

cnorm1(x):=block([u:expand(x), sgn:sign(%ivnorm) ],
	 psnorm (u, sgn)
);

psdet():=product(aform[k,k], k, 1, ndim);

/*
symmetric bilinear form of the algebra; 
*/
psnorm(x, sgn):=block([u, z, v, ss:0, neg:-1, l, r, ret ],
	if not (sgn='minus or sgn='neg or  sgn='plus or sgn='pos ) then 
		error("plus, pos, neg or minus expected"),	
	
	if mapatom(x) then return (x.x),
	if sgn=plus or sgn=pos then neg:1,
	if not freeof(".",x) then u:expand(x) 
	else u:x,
	
	if nterms(u)>1 then (
		[l,r]: oppart (u, lambda ([u], freeof(asymbol, u))),
		if _debug=true then display(l,r),
		if nterms(r)>1 then (
			for v in r do 
				ss:ss + apply1(v.v, clifsimp10),
			ret:neg*ss + l^2
		) else
			ret: l^2+ neg*apply1(r.r, clifsimp10)
	)else 
		ret:neg*apply1(u.u, clifsimp10),
	subst('nil=0, ret)	
);

/**
vector predicate
*/
vectorp(v):= (
	if not freeof(".", v) then v:expand(v),
	freeof(".", v) and not freeof(asymbol, v)
);


/*
 grading functions
*/

/*
 scalar part
*/
scalarpart(v):=block([ r, l, sop ],
	if freeof(asymbol, v) then return (v),
	if not freeof(".", v) then v:expand(v),
	sop: inop(v),
	if sop="+" then (
		[r,l]: oppart(v, lambda([u], freeof(asymbol, u))),
		r:subst('nil=0, r)
	) else 
		if freeof(asymbol, v) then  r:v 
		else r:0,
	r
);

/*
 vector part
*/
vectorpart(v):=block([gr],
	if freeof(asymbol, v) then return (0),
	gr:grade(v),
	gr[2]
);

/*
 multivector part
*/
mvectorpart(v):=block([ r, l ],
	if freeof(asymbol, v) then return (0),
	gr:grade(v),
	gr:sublist(gr, lambda([u], not freeof(".", u))),
	if emptyp(gr) then 0 else
		substinpart("+", gr, 0)
);

/**
 grade of order k
*/

grpart(v,k):=block([gr],
	if k>ndim+1 then k:ndim+1,
	gr:grade(v),
	gr[k]
);

/**
 Application functions
*/


/**
 dual element
*/
dual(x):=x.%iv;

conjel(x, k):= (asymbol[k]. x)/asymbol[k]	;

/**
 projection
*/
project(a, v):=block ([ m:cnorm(v)] ,
	if m=0 then m:1,
	if m<0 then m:-m,
	cliffsimpall(v.(a ~ v)/m)
);


/*
dual to the projection
*/
reject(a, v):=block ([ m:cnorm(v)] ,
	if m=0 then m:1,
	if m<0 then m:-m,
	cliffsimpall(v.(v & a)/m)
);


/**
 reflection
*/
reflect(a, v):=block ([ m:cnorm(v)],
	if m=0 then m:1,
	if m<0 then m:-m,
	cliffsimpall(cconjugate(v).a.v/m)
);


/**
 rotation
*/
rotate(a, v):=block ([ m:cnorm(v)],
	if m=0 then m:1,
	if m<0 then m:-m,
	cliffsimpall(v.a.creverse(v)/m)
);

 
/**
 checks if an element is an idempotent
*/
idemp(u):=block([v, ret],
	v:expand(u.u),
	v:ratsimp(v-u),
	ret: is(equal (v, 0)),
	if ret#true then false else true
);

/*
 Analysis functions
*/

cvect(x, [cc]):=block ([ss:0],
	if emptyp(cc) then
		ss:sum (x[i]*asymbol[i], i, 1, ndim)
	else (
		cc:cc[1],
		for i:1 thru length(cc) do 
			if not emptyp(cc[i]) then
			ss: ss+ x[ cc[i] ]*asymbol[i]
		),
	ss
);

celem(x, [cc]):=block([ee:elements(all), n],
	n:length(ee),
	if emptyp(cc) then
		sum (x[i]*ee[i], i, 1, n)
	else (
		cc:cc[1],
		sum (x[ cc[i] ]*ee[i], i, 1, length(cc))
		)
);

/*
 vector derivative
*/
vectdiff(f, x, [k] ):=block ([s, n:1, m, i ],
	if listp(x) then n:length(x) else x:[x],
	if n>ndim then error("size mismatch"),
	if emptyp(k) then k:1 else k: k[1],

	for p:1 thru k do (
		i:1, s:0,
		for m in x do (
			if not emptyp(m) then
				s: s+ dotinvsimp(1/asymbol[i]). subst(".", "*", diff( f, m )),
			i:i+1
		),
		s:cliffsimpall(s),
		f:s
	),
	s
);

/*
 multi vector derivative
*/
mvectdiff(f, x, [k] ):=block ([s, n:1, m, i, ee, xx ],
	[ee, xx]:clicoeff(x, 'list),
	if emptyp(k) then k:1 else k: k[1],
	for p:1 thru k do (
		i:1, s:0,
		for m in xx do (
			if mapatom(m) then 
				s: s+  dotinvsimp(1/ ee[i]) . subst(".", "*", diff( f, m ) ),
			i:i+1
		),
		s:cliffsimpall(s),
		f:s
	),
	s
);

/*
 directional, inner, derivative
*/
svectdiff(f, x, [k] ):=block ([s, n:1, m, i, ee, xx ],
	[ee, xx]:clicoeff(x,'list),
	if emptyp(k) then k:1 else k: k[1],
	for p:1 thru k do (
		i:1, s:0,
		for m in xx do (
			if mapatom(m) then
				s: s+  dotinvsimp(1/ ee[i]) ~ subst(".", "*", diff( f, m )),
			i:i+1
		),
		s:cliffsimpall(s),
		f:s
	),
	s
);

/*
 exterior, dual, vector derivative
*/
vvectdiff(f, x, [k] ):=block ([s, n:1, m, i, ee, xx ],
	[ee, xx]:clicoeff(x, 'list),
	if emptyp(k) then k:1 else k: k[1],
	for p:1 thru k do (
		i:1, s:0,
		for m in xx do (
			if mapatom(m) then
				s: s+  dotinvsimp(1/ ee[i]) & subst(".", "*", diff( f, m )),
			i:i+1
		),
		s:cliffsimpall(s),
		f:s
	),
	s
);



EuLagEq1(_F, tt, pvars):=block ([eq:0, p, pv, len, ret:[]],
	[p, pv]:pvars,
	display(p, pv),
	if listp(p) then
		for i:1 thru length (p) do
			push(pv[i]='diff(p[i], tt), ret)
	else 
		push(pv='diff(p, tt), ret),
	eq:vectdiff(_F, p)-diff(vectdiff(_F, pv), tt),
	[ ret, eq=0]
);

EuLagEq2(_F, tt, pvars):=block ([eq:0, p, pv,   ret:[]],
	[p, pv]:pvars,
	display(p, pv),
	if listp(p) then
		for i:1 thru length (p) do
			push(pv[i]='diff(p[i], tt), ret)
	else 
		push(pv='diff(p, tt), ret),
	eq:vectdiff(_F, pv),
	eq:vectdiff(_F, p)-subst( 'diff(p, tt), 'pv(tt),  diff( subst('pv(tt), pv, eq), tt ) ) = 0
);
 

dependsv(F, var):= block([ ee], 
	ee:buildq([var], declare(var, scalar) ), 
	ev(ee, nouns),
	ee:buildq([var],  makelist(var[k],k, ndim) ), 
	ev(depends(F,ee), nouns)
);



put('clifford, 'v17,'version);
put('clifford, "Dimiter Prodanov", 'author);
put('clifford, "(C) - Dimiter Prodanov, 2015", 'copyright);

disp("package name: clifford.mac");
disp("author: ", get('clifford,'author));
disp("version:", get('clifford,'version));
disp("Recommended location: share/contrib");
disp("last update: 14 Nov 2015");