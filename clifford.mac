/*******************************
Clifford algebra
a lightweight package for performing Geometric Algebra calculations

 v 	1.5.5 Data 04 Nov 2015
	- bugixes oppart
	- unit tests
	
	1.5.1 Date 30 Oct 2015
	- bugfixes oppart
	1.4 Date 22 Aug 2015
	- oppart simplified
	
	1.3 Date 11 Jun 2015
**********************************
 * @license This library is free software; you can redistribute it and/or
 *      modify it under the terms of the GNU Lesser General Public
 *      License as published by the Free Software Foundation; either
 *      version 2.1 of the License, or (at your option) any later version.
 *
 *      This library is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *       Lesser General Public License for more details.
 *
 *      You should have received a copy of the GNU Lesser General Public
 *      License along with this library; if not, write to the Free Software
 *      Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 matchdeclare(aa, lambda([u], not freeof(asymbol,u)), [bb,cc], true, [kk, mm, nn], integerp);
 
"vector symbol";
asymbol:e;
"number of dimensions";
ndim:0;
signature:[];
esignature:[];
"pseudoscalar";
%iv:1;
"squre of pseudoscalar";
%ivnorm:1;

_debug:false;
dotexptsimp :false;
noundisp :true;
dotscrules:true;
powerdisp:true;

/*
 custom operators
*/
(	
	"innter product",
	infix ("~", 130, 129),
	"~"(a, b):= if scalarp(a) and scalarp(b) then a*b else expand((a.b + b.a)/2),
	texput ("~", " \\circ ", infix),
	
	"outer product",
	infix ("&", 130, 129),
	"&"(a, b):=if scalarp(a) and scalarp(b) then 0 else expand((a.b - b.a)/2),
	texput ("&", " \\wedge ", infix)
);

inop(expr):= if not mapatom (expr)  then 
	inpart(expr, 0)
	else 'nil; 

inargs(expr):= if not mapatom (expr)  then  substinpart( "[", expr, 0) else 'nil;

/*
partition by predicate with expression reconstruction
literal meaning
*/
oppart(expr, predf):=block(
	[sop, lst, lsttrue:[], lstfalse:[], ltrue, lfalse, err ],
	mode_declare([lsttrue, lstfalse, lst, err], list),
	if mapatom(expr) then (
		if apply(predf,[expr]) then (ltrue:expr, lfalse:'nil)
		else (lfalse:expr, ltrue:'nil),
		return( [ltrue, lfalse])
	) else (
		sop:inop(expr),
		expr:rest(expr, 0),
		lst: inargs(expr),
		if _debug=true then print("sop ", sop, "lst ", lst), 
		for v in lst do (
			if apply(predf, [v]) then push(v, lsttrue) 
			else push(v, lstfalse)
		),
		lsttrue:reverse(lsttrue),
		lstfalse:reverse(lstfalse),
		if _debug=true then print("l ", lsttrue, " ; r ",lstfalse),  
		err:errcatch (
			ltrue:if not emptyp(lsttrue) then 
				substinpart(sop, lsttrue, 0) 
				else  'nil,
			lfalse:if not emptyp(lstfalse) then 
				substinpart(sop, lstfalse, 0) 
				else  'nil,	
		 	if _debug=true then print("lt ", ltrue, " ; lf ", lfalse), 
			/*if lfalse=nil or ltrue=nil  then lst:[  lfalse, ltrue] else
			*/
			lst:[ ltrue, lfalse]
			/* if sop="+" then lst:subst('nil=0, lst),
			if sop="*" or sop="."  then lst:subst('nil=1, lst) */
		),
		if emptyp(err) then lst([expr, 'nil])
	),
	lst
); 
 
/*
counts occurences of an operator in an expression
*/
countop(ab, sop):=block([a, b, c, s:0, piece, inflag :true ],
if not mapatom(ab) then 
	 errcatch (
		a:inpart(ab,0),
		b:inpart(ab,1),
	 	c:rest(ab,1),
		if _debug=true then print (b, c),
		if a=sop then s:s+1,
		if freeof (sop, c) then
			s:s +  countop(b, sop) 
		else 
			s:s +  countop(c, sop) 
	),
	s
);

 
 /*
partition by predicate with expression reconstruction
heuristical meaning
*/
oppartexp(expr, predf):=block([ lsttrue, lstfalse],
	expr:expand(expr),
	[ lsttrue, lstfalse]:oppart(expr, predf),
	lsttrue:ratsimp(lsttrue),
	lstfalse:ratsimp(lstfalse),
	return ([ lsttrue, lstfalse])
 );
 
/*
simplification of dot-products, ordergreat
*/
dotsimp1(ab):=block([a, b],
  if atom(ab) or op(ab)#"." then return(ab),
  a:inpart(ab,1),
  b:inpart(ab,2),
 if orderlessp(a,b) then -b.a else ab
);

/*
simplification of dot-products, orderless
*/
dotsimp2(ab):=block([a, b],
  if atom(ab) or op(ab)#"." then return(ab),
  a:inpart(ab,1),
  b:inpart(ab,2),
  if ordergreatp(a,b) then -b.a else ab
);

/*
toggles debugging
*/
toggle_debug():= _debug: not _debug;

/*
simplification of dot-products
*/
declare (dotsimpc, evfun);

dotsimpc(ab):=block([ba, c:1, v, w:1, q],
  mode_declare([w], fixnum),
  if mapatom(ab) or freeof(".", ab) or inop(ab)="+"  then return(ab),
  ba:copy(ab),
  v:inargs(ba),
  if _debug=true then print("op ", op(ba), "v ", v),
  w:permsign(v),
  v:sort(v),
  for q in v do c:c.q,
  if _debug=true then  print(w, v),
  w*c 
);

/*
internal function: parity of permutation calculation
*/
permsign(arr):=block([k:0, len] ,
	mode_declare([k, len], fixnum),
	if not listp(arr) then return (false),
	len:length(arr),
	for i:1 thru len do
		for j:i+1 thru len do
			if ordergreatp(arr[i], arr[j]) then k:k+1,
	if evenp(k) then 1 else -1
);

/*
simplification rules
*/
matchdeclare(dd, lambda([u],  freeof(asymbol, u)));
defrule (clifsimp1, dd*aa, dd*dotsimpc(aa));
defrule (clifsimp10, aa, dotsimpc(aa));
defrule (clifsimp2, dd/aa, dd*dotinvsimp(1/aa));

/*
full simplification of expressions
*/
declare (cliffsimpall, evfun);
cliffsimpall(expr):=block([res],
	res:expand(expr),
	res:apply1(res, clifsimp2, clifsimp1, clifsimp10),
	ratsimp(res)
);

/*
simplification of dot-products
*/
cliffsimp1(expr):=block([res],
	res:expand(expr),
	apply1(res, clifsimp1, clifsimp10)
);


/*
 simplification of inverses
*/
declare (dotinvsimp, evfun);
dotinvsimp(ab):=block( [a,b,s],
 mode_declare([a,b,s], any),
 if atom(ab) or freeof(asymbol, ab) or op(ab)#"/" then return(ab),
  a:part(ab,1),
  b:part(ab,2),
  s: expand(b.b),
  if not freeof(asymbol, s) then  s:cliffsimp1(s),
  if s#0 then a.b/s else ab 
);



/*
Clifford inverse
*/
cinv(ab):=block( [s, b, u:1],
 if atom(ab) or freeof(asymbol, ab) then return(1/ab),
  b:cconjugate(ab),
  s:expand(b.ab),
  if not freeof(asymbol, s) then s: apply1(s, clifsimp10, clifsimp2),
  if s-scalarpart(s)#0 then ( 
	u:creverse(s),
	s:expand(s.u),
	s: apply1(s, clifsimp10),
	print(s)
  ),
  if s#0 then (
	b:expand(b.u),
	b:apply1(b, clifsimp10),
	return(b/s)
  )else return(1/ab)
);


/*
simplification of exponents
*/
powsimp(aa):=block( [a,k,p],
  if atom(aa) then return(aa),
  if op(aa)="^^" or op(aa)="^" then (
	  a:inpart(aa,1),
	  k:inpart(aa,2),
	  p:inpart(a,1),
	  if _debug=true then print(a,k,p),
	  if not integerp(k) then return(aa),
	  if evenp(k) then 
	  aform[p,p]^fix(k/2) 
  else  aform[p,p]^fix(k/2)*a )
  else aa
 );

if get('clifford,'version)=false then (
	tellsimp(aa[kk].aa[kk], aform[kk,kk] ),
	tellsimpafter(aa[kk].aa[mm], dotsimp2(aa[kk].aa[mm])),
	tellsimpafter(bb.aa.cc, apply1(bb.aa.cc, clifsimp10)),
	tellsimpafter(aa[kk]^nn, powsimp(aa[kk]^nn)),
	tellsimpafter(aa[kk]^^nn, powsimp(aa[kk]^^nn))
); 

/*
constructor of the algebra
*/
clifford(var, [lsig]):=block([m, a, p:0, n:0, r:0],
	if emptyp(lsig) or length(lsig)>3 then error(" invalid signature"),
	p:lsig[1],
	if length(lsig)=2 then 
		n:lsig[2],
	if length(lsig)=3 then (
		n:lsig[2], 
		r:lsig[3]
	),
	if not (numberp(n) or numberp(p) or numberp(r)) then error(" provide numbers"),
	m:p+r+n,
	if _debug=true then print(m,p,n,r),
	if m<=0 then return (false),
	local (a),
	a[i,j]:= if i#j then 0 else (
		if i<=p then 1 else if i>n+p then 0 else -1
	),
	ndim:m,
	makebasis(var),
	signature:makelist(a[i,i], i, m),
	%iv:pscalar(),
	aform:genmatrix (a, m, m),
	%ivnorm:dotsimpc(%iv.%iv),
	signature
);


/*
sets the signature of the algebra
*/
set_signature(arr):=block(
	if not listp(arr) or length(arr)#ndim then return(false),
	signature:arr,
	for i:1 thru ndim do
		aform[i,i]:arr[i],
	%iv:pscalar(),
	%ivnorm:dotsimpc(%iv.%iv),
	aform
);

/*
toggles the signature of the algebra
*/
toggle_signature():=block(
	signature:-signature,
	aform:-aform,
	%iv:pscalar(),
	%ivnorm:dotsimpc(%iv.%iv)
);

/*
constructs the complete basis of the algebra
*/
makebasis(var):= block([ ee], 
	asymbol: var,
	ee:buildq([asymbol], array(asymbol, ndim)), 
	ev(ee,nouns)
);

/*
constructs the pseudoscalar of the algebra
*/
pscalar():=block([s:1],
	for i:1 thru ndim do s:s.asymbol[i],
	s
);

/*
releases all rules 
*/
release():=block(
	remrule ("^^",  all),
	remrule ("^",  all),
	remrule (".",  all),
	remrule ("*",  all),
	rem('clifford,'version),
	rem('clifford,'author),
	rem('clifford,'copyright)
);

/*
grade decomposition of expressions
*/
grade(expr):=block([c, sop, k],	
	local(c),
	array(c, fixnum, ndim),	
	if not mapatom(expr) then 
		expr:expand(expr),
	
	sop: inop(expr),
	if sop="+" then (
		for v in expr do (	
			k:countop(v, "."),
			if _debug=true then print("k= ", k, " v= ", v),
			if freeof (asymbol, v ) then
				c[k]:c[k] +v 
			else 
				c[k+1]:c[k+1] +v
		)
	)else ( "simple expression, we count only the dots",
		k:countop(expr, "."),
		if freeof (asymbol, expr ) then
			c[k]:c[k] +expr 
		else 
			c[k+1]:c[k+1] +expr
	),
	listarray(c)
);

/*
grade decomposition of expressions
 
grade(expr):=block([ c, v, k, r, l, s],	
	"atomic cases",
	if mapatom(expr) then (
		if _debug=true then print("case atom ", expr),
		c:makelist(0,ndim+1),
		c[1]:expr,
		return(c)
	)elseif op(expr)=asymbol then  (
		if _debug=true then print("case asymbol ", expr),
		c:makelist(0,ndim+1),
		c[2]:expr,
		return(c)
	),
	expr:expand(expr),
	"compound cases",
	if op(expr)#"+" and op(expr)#"-" and op(expr)#"*" and op(expr)#"." then return(false),
	local(c),
	array(c, fixnum, ndim),
	if op(expr)="." then (
		k:length(expr),
		c[k]:expr
	) elseif op(expr)="*" then (
		if _debug=true then print("case * " , expr),
		c[1]:expr
	) else (
		v:args(expr),
		if _debug=true then print("case 4 " , op(expr), v),
		if op(expr)="-" then v:-v,
		for i:1 thru length(v) do (
			if not freeof(".", v[i]) then (
				if _debug=true then print( "case 5 " , v[i]),
				if freeof("*", v[i]) then (
					k:length(v[i]),
					c[k]:c[k]+v[i]
				) else (				
					[l,r]:partition(v[i], "."),
					if _debug=true then print("case 6 " , l, r),
					s:args(r),
					k:length(s),
					c[k]:c[k]+v[i]
				)
			) else 
				if freeof(asymbol, v[i]) then 
					c[0]:c[0]+v[i]
				else 
					c[1]:c[1]+v[i]
		)
	),
	listarray(c)
);
*/

/*
computes the element decomposition
*/
clicoeff(expr):=block([c, ee, sop, k, r,l],	
	local(c, ee),
	c:make_array(hashed, 2^ndim),
	 
	ee:make_array(hashed, 2^ndim),
	if not mapatom(expr) then 
		expr:expand(expr),
	
	sop: inop(expr),
	if sop="+" then (
		for v in expr do (				 
			if _debug=true then  display(  v),
			if freeof (asymbol, v ) then (
				if c[1]=false  then c[1]:v else
				c[1]:c[1]+v,
				if ee[1]=false  then ee[1]:1
			)
			else (
				[l,r]: oppart (v, lambda ([u], freeof(asymbol, u))),
				if _debug=true then display(r,l),
				if c[r]=false  then c[r]:l else
				c[r]:c[r] +l,
				if ee[r]=false  then ee[r]:r
				)
		)
	)else ( "simple expression, separate",
		 if freeof (asymbol, expr ) then (
				c[1]:expr, 
				ee[1]:expr
			)
			else (
			[l,r]: oppart (expr, lambda ([u], freeof(asymbol, u))),
			if _debug=true then display(r,l),
			c[ r]:l,
			ee[ r]:r
		 )
	),
	[listarray(ee), listarray(c)]
);
/*
Clifford transpose of product
*/
ctranspose(x):=block ([l, v:0, len, k],
	if not freeof(".",x) then 
		l:grade(expand(x))
	else 
		l:grade(x),
	len: length(l),
	for i:1 thru len do (
		k:mod(i-1,4), 
		k: (if k<2 then 1 else -1),
		v:v+ k * l[i] 
	),
	v
);


/*
Clifford reverse of expressions
*/
creverse(ab):=block([a, b, sop: inop(ab), len],
  if atom(ab) or freeof(".",ab) then return(ab),
  if sop="." then (
	  b: dotreverse(ab),
	  return(b)
  ) else (
	  b: inargs(ab),
	  len:length(b),
	  for i: 1 thru len do
		b[i]:dotreverse(b[i]),
		if _debug=true then  print(b),
	    b:substinpart(sop,b,0)
  ),
  b
);

/*
Clifford reverse of dot-product, recursive
*/
dotreverse(ab):=block([a, b],
  if atom(ab) or subvarp (ab) then return(ab),
  errcatch (
	a:inpart(ab,1),
	b:rest(ab,1),
	if _debug=true then print(a,b),
	if inop(ab)="." then
	  return(dotreverse(b). dotreverse(a))
	elseif inop(ab)="*" then
	  return(dotreverse(b)* dotreverse(a))
  ),
  reverse(ab)
);


	

/*
Clifford involution of expressions
*/
cinvolve(x):=block ([l, v:0, len, k],
	if not freeof(".",x) then 
		l:grade(expand(x))
	else 
		l:grade(x),
	len: length(l),
	for i:1 thru len do (
		k:mod(i-1,4), 
		k: (if k=0 or k=2 then 1 else -1),
		v:v+ k * l[i] 
	),
	v
);


/*
Clifford conjugate of expressions
*/
cconjugate(x):=block ([l, v:0, len, k],
	if not freeof(".",x) then 
		l: grade(expand(x))
	else 
		l:grade(x),
	len: length(l),
	for i:1 thru len do (
		k:mod(i-1,4), 
		k: (if k=1 or k=2 then -1 else 1),
		v:v+ k * l[i] 
	),
	v
);


/*
constructs all  irreducible elements of the algebra 
*/
elements():=block([c:1, lst:[] ],
	for i:1 thru ndim do c:c.(1+ asymbol[i] ),
	c:expand(c),
	lst:inargs(c),
	pop(lst),
	sort(lst, lambda([u,v], ordergreatp(u,v) and length(u)<length(v)))
);



/*
constructs coefficient list of the vector elements
*/
velem(expr):=block([cc:[], u : expand(expr)],
	for i:1 thru ndim do
		cc:endcons(coeff (u, asymbol[i]), cc),
	cc
);


gpoly(expr):=block([cc:[], u:(expr), z, len],
	if op(u)#"." then  (
		cc:oppartexp(u, lambda([z], freeof(".", z))),
		u:cc[2]
	),
	cc:substinpart("[", u, 0),
	len:length(cc),
	"print(cc, len)",
	if len>1 then (
		z: sum (cc[i], i, 1, len),
		cc:endcons(z, cc)
	), 
	"print(cc)",
	cc:maplist (velem, cc),
	cons(makelist(0, ndim),cc)
);
/*
draws a vector
opt - selects the subspace to draw - list of indices
*/
vdraw(expr, [opt]):=block( [scenes:[], cc, cc1, m:1, dd, n:0, cstr],
	if not listp(expr) then expr:[expr],
	m:length(expr),
	for j:1 thru m do (
		cc:[], cc1:[], 
		"print(expr[j])",
		cc:velem(expand(expr[j])),
		dd:makelist(0, ndim),
		if not emptyp(opt) then n:length(opt),
		if n>ndim then (
			for i:1 thru n do
				cc1[i]:cc[opt[1]],
			cc:cc1
		),
		"cstr:string(tex(expr[j], false))",
		cstr:(string(expr[j])),
		scenes:cons([ 
			  label(cons(cstr, makelist(1.25*cc[i],i,ndim) )),
			  color = blue,
			  head_length = 0.2,
			  head_angle  = 20,
			  line_width = 3,
			  head_type = 'filled,
			  vector(dd, cc)], scenes
		)
	),
	if ndim<=2 then 
		wxdraw2d(scenes) 
	else
		wxdraw3d(scenes)
);


/*
draws a bi-vector
*/
vdraw2(expr):=block( [scenes:[], cc, cc1, m:1, dd, n:0],
	if not listp(expr) then expr:[expr],
	m:length(expr),
	for j:1 thru m do (
		cc:gpoly(expr[j]),
		print(cc),
		cstr:(string(expr[j])),
		scenes:cons([ 
			  label(cons(cstr,  1.25*cc[3] )),
			  color = blue,
			  fill_color =red,
			  fill_density=0.5,
			  line_width = 2,
			  quadrilateral (cc[1], cc[2], cc[3], cc[4]) ], scenes
		)
	),
	if ndim<=2 then 
		wxdraw2d(scenes) 
	else
		wxdraw3d(scenes)
);


/**
 multiplication table, all elements
*/
mtable2():=block([n, a, lst],
	local (a),
	lst: elements(),
	push(1,lst),
	n:length(lst),
	if _debug then 
	a[i,j]:= (lst[i].lst[j]) else
		a[i,j]:= dotsimpc(lst[i].lst[j]),
	genmatrix(a,n,n)
);

/**
 multiplication table, reduced
*/
mtable1():=block([n, a, lst],
	local (a),
	lst:makelist(asymbol[i], i, ndim),
	push(1,lst),
	n:length(lst),
	a[i,j]:= dotsimpc(lst[i].lst[j]),
	genmatrix(a,n,n)
);



/**
 norm
*/
cliabs(x):=block([u:expand(x)],
	u:expand(u.cconjugate(u)),
	u:scalarpart(u),
	u:sqrt(u),
	radcan(u)
);


/**
 scalar product
*/
scprod(x, y):=block([u:expand(x), v:expand(y)],
	u:expand(ctranspose(u).v),
	u:scalarpart(u),
	u:sqrt(u),
	radcan(u)
);

/**
 multiplication table, trace
*/
multtrace():=block([s:[1], lst],
	lst:elements(),
	push(1, lst),
	for i:1 thru length(lst) do 
		s:endcons(dotsimpc(lst[i].lst[i]), s),
	s
);

/**
norm^2, experimental

cnorm(x):=block([u:expand(x), z, v],
	u:expand(u. cconjugate(u)),
	u:cliffsimpall(u),
	u:scalarpart(u),
	u:ratsimp(u)
);
 */
cnorm(x):=block([u:expand(x), z:0],
	 if %ivnorm < 0 then z:psnorm (u, plus)
	 else z:psnorm (u, minus),
	 z
);

/*
 
defrule(csubst2, bb*asymbol[kk], sqrt(-aform[kk,kk])*bb);
defrule(csubst, bb*asymbol[kk], aform[kk,kk]*bb);

 
defrule(csubst3,  asymbol[kk], 0);
defrule(csubst31, bb*asymbol[kk], 0);
*/
/*
symmetric bilinear form of the algebra;
used to compute the norm
 
psnorm(x, sgn):=block([u, z, v, neg:true ],
	if not freeof(".",x) then 
		u:expand(x) 
	else u:x,
	if mapatom(x) then return (x*x),
	if sgn=plus then neg:false 
	elseif sgn#minus then 
		error("plus or minus expected"),
		
	if inop(u)="+" then ( 
		v:inargs(u),
		v:sort(v),
		 disp(v),
		z: (if neg then apply1(v, csubst2) else apply1(v, csubst))
	) else (
		z:(if neg then apply1(u, csubst2) else apply1(u, csubst))
	),
	u:z.z,
	disp(u),
	ratsimp(u)
);
*/
psnorm(x, sgn):=block([u, z, v, neg:true ],
	if mapatom(x) then return (x*x),
	if sgn=plus then neg:false
	elseif sgn#minus then 
		error("plus or minus expected"),
		
	if not freeof(".",x) then 
		u:expand(x) 
	else u:x,
 	
	if inop(u)="+" then ( 
		v:inargs(u),
		z: subst (asymbol= lambda([k], if neg then sqrt(-aform[k,k]) else (aform[k,k]) ), v )
	) else  
		z: subst (asymbol= lambda([k], if neg then sqrt(-aform[k,k]) else (aform[k,k]) ), u ),
	if listp(z) then (
		u: lsum(x^2, x, z),
		if _debug=true then disp(u),
		ratsimp(u)
		)
	else z
);

/**
vector predicate
*/
vectorp(v):= freeof(".", v) and not freeof(asymbol, v);


/*
 grading functions
*/

/*
 scalar part
*/
scalarpart(v):=block([ r, l ],
	if not freeof(".", v) then v:expand(v),
	[r,l]: oppart(v, lambda([u], freeof(asymbol, u))),
	subst('nil=0, r)
);

/*
 vector part
*/
vectorpart(v):=block([ r, l ],
	if not freeof(".", v) then v:expand(v),
	[r,l]: oppart(v, lambda([u], vectorp(u))),
	subst('nil=0, r)
);

/*
 multivector part
*/
mvectorpart(v):=block([ r, l ],
	if not freeof(".", v) then v:expand(v),
	[r,l]: oppart(v, lambda([u],  freeof(".", u) )),
	subst('nil=0, l)
);

/**
 grade of order k
*/

grpart(v,k):=block([gr],
	if k>ndim+1 then k:ndim+1,
	gr:grade(v),
	gr[k]
);

/**
 Application functions
*/


/**
 dual element
*/
dual(x):=x/%iv;

/**
 projection
*/
project(a, v):=block ([ m:cnorm(v)] ,
	if m=0 then m:1,
	if m<0 then m:-m,
	cliffsimpall(v.(a ~ v)/m)
);


/*
dual to the projection
*/
reject(a, v):=block ([ m:cnorm(v)] ,
	if m=0 then m:1,
	if m<0 then m:-m,
	cliffsimpall(v.(v & a)/m)
);


/**
 reflection
*/
reflect(a, v):=block ([ m:cnorm(v)],
	if m=0 then m:1,
	if m<0 then m:-m,
	cliffsimpall(cconjugate(v).a.v/m)
);


/**
 rotation
*/
rotate(a, v):=block ([ m:cnorm(v)],
	if m=0 then m:1,
	if m<0 then m:-m,
	cliffsimpall(v.a.creverse(v)/m)
);

 
/**
 checks if an element is an idempotent
*/
idemp(u):=block([v, ret],
	v:expand(u.u),
	v:ratsimp(v-u),
	ret: is(equal (v, 0)),
	if ret#true then false else true
);

/*
 application functions
*/

cvect(x):=sum (x[i]*asymbol[i], i, 1, ndim);

celem(x):=block([ee:elements(), n],
	ee:cons(1,ee),
	n:length(ee),
	sum (x[i]*ee[i], i, 1, n)
);

/*
 vector derivative
*/
vectdiff(f, x, [k] ):=block ([s, n:1, m, i ],
	if listp(x) then n:length(x) else x:[x],
	if n>ndim then error("size mismatch"),
	if emptyp(k) then k:1 else k: k[1],
	
	for p:1 thru k do (
		i:1, s:0,
		for m in x do (
			if not emptyp(m) then
				s: s+ dotinvsimp(1/asymbol[i]).(diff( f, m )),
			i:i+1
		),
		s:expand(s),
		s:cliffsimpall(s),
		f:s
	),
	s
);

/*  
EuLagEq1(_F, q, pvars):=block ([eq:0, p, z:1, len, ret:[]],
	if not listp(pvars) then pvars:[pvars], 
	 p:pvars[1],
	 eq:diff(_F, p),
	 len:length(pvars),
	 if len>1 then 
		 for i :2 thru len do (
			p:pvars[i],
			depends(p, q),
			eq:eq + (-1)^z*diff(diff(_F, p), q, z),
			push(p='diff(pvars[1], q, i-1), ret),
			z:z+1
		 ),
	ret:reverse(ret),
	[ ret, eq=0]
);
  */


EuLagEq1(_F, tt, pvars):=block ([eq:0, p, pv, len, ret:[]],
	[p, pv]:pvars,
	display(p, pv),	
	if listp(p) then
		for i:1 thru length (p) do
			push(pv[i]='diff(p[i], tt), ret)
	else 
		push(pv='diff(p, tt), ret),
	eq:vectdiff(_F, p)-diff(vectdiff(_F, pv), tt),	
	[ ret, eq=0]
);

EuLagEq2(_F, tt, pvars):=block ([eq:0, p, pv,   ret:[]],
	[p, pv]:pvars,
	display(p, pv),
	if listp(p) then
		for i:1 thru length (p) do
			push(pv[i]='diff(p[i], tt), ret)
	else 
		push(pv='diff(p, tt), ret),
	depends(pv, tt),
	eq:vectdiff(_F, p)-diff(vectdiff(_F, pv), tt),	
	eq:subst(ret, eq=0),
	remove (pv, dependency),
	eq
);
 

dependsv(F, var):= block([ ee], 
	ee:buildq([var], (
		declare(var, scalar),
		makelist(var[k],k, ndim)
		)
	), 
	ev(depends(F,ee), nouns)
);

/*
 experimental code for Clifford exponentiation
*/
cliexp(expr):=block([v, gr, p, q:[], s:1], 
	if not freeof(%e, expr) and op(expr)="^" then (
		v:args(expr),
		gr:grade(v[2]),
		if not gr then gr:[v[2]],
		display(  gr),	
		for p in gr do (
			if not mapatom(p) then (		
				if op(p)="+" then (
					for pl in args(p) do
					q:cons (ceparse(pl),q)
				),
				print(" + ", p, q)
			) else 
				q:cons(ceparse(p),q)
		),
		print ("p" ,p, " qf ", q),
 
		s: substinpart(".", q, 0)
	) else expr
);


ceparse(p):=block([l,r,s, q:1],
	[l,r]:oppart(p, lambda([u], freeof (asymbol, u)) ),
/* 	print ("l ", l,"r ", r), */
	if r=1 then q:exp(l) 
	else (
		s: cliffsimp1(r.r),
	/* 	print(s), */
		if s<0 or sign(s)=minus then q: cos(l)+r*sin(l),
		if s>0 or sign(s)=plus then q: cosh(l)+r*sinh(l),
		if s=0 or sign(s)=zero then q: 1+ r*l
	),
	q
);

put('clifford, 'v16,'version);
put('clifford, "Dimiter Prodanov", 'author);
put('clifford, "(C) - Dimiter Prodanov, 2015", 'copyright);

disp("package name: clifford.mac");
disp("author: ", get('clifford,'author));
disp("version:", get('clifford,'version));
disp("Recommended location: share/contrib");
disp("last update: 07 Nov 2015");